Arguments and Results
---------------------
Эти два понятия ключевые. Subtype должен "принимать" НЕ МЕНЬШЕ родителя, от "отдавать" НЕ БОЛЬШЕ
родителя. Термин "принимать" относится к аргументам, термин "отдавать" к возвращаемому значению.
Т.е. все как у функции.

В результате при создании наследника (subtype'а) мы можем РАСШИРЯТЬ количество ПРИНИМАЕМЫХ типов
и СУЖАТЬ количество ОТДАВАЕМЫХ типов. РАСШИРЯТЬ - это значит двигаться в сторону Any, а СУЖАТЬ - 
двигаться в сторону Nothing.

NOTE: В Kotlin (Java) запрещена КОНТРвариантность аргументов функций при наследовании классов
и интерфейсов. См. здесь: (https://typealias.com/concepts/contravariance/#functions). И как это
обойти здесь: https://typealias.com/concepts/contravariance/#properties

То есть наследник не может сделать override функции указав ей расширенный тип аргумента !!!

=======================================


Subtype не должен ничего поломать. А именно, subtype должен принимать НЕ МЕНЬШЕ родителя
и отдавать НЕ БОЛЬШЕ родителя. То есть для внешнего мира он должен выглядеть как родитель.

Всегда нужно помнить, что КЛАСС это не есть тип когда дело касается дженериков.
Дженерик становится типом только после того как указаны КОНКРЕТНЫЕ ТИПЫ для
всех его type parameters. Тип можно указать просто, например <Animal>, или с использованием
type-projection, например <in Dog>, или <out Cat> или вообще <*>. 
Type-projection - это ТИП.

И вот только после того как мы создали типы можно говорить об отношениях "type <- subtype".
Дженерики ИНВАРИАНТНЫ, то есть до тех пор пока у нас есть только

interface Group<T> {
	fun insert(item: T): Unit
	fun fetch(): T
}

говорить о какой-то наследственности от Group бессмысленно потому что не определено 
на базе каких конкретных T эту наследственность строить.


P.S.

declaration-site variance
--------------------------

Это когда в момент ДЕКЛАРИРОВАНИЯ дженерика мы сразу накладываем ограничения на вариантность
его будущих инстансов.
Например:

interface Group<in T> {
	insert(item: T): Unit
}

use-site variance
-----------------

Это когда ограничения на вариантность накладываются в точке использования дженерика. И в этой точке компилятор
сгенерит "новый" subtype для Group<T>

Например указываем в коде: 
fun read(group: Group<out Dog>) = println(group.fetch())

и компилятор генерит подтип такого вида:

interface Group<out Dog> {
	fun insert(item: Nothing): Unit
	fun fetch(): Dog
}

В итоге group (аргумент функции read) имеет тип "type-projection Group<out Dog>"

Обрати внимание, что в тот момент как мы определили type-projection через use-site variance,
то мы создали новый ТИП, основателя иерархии наследования, корень новой иерархии. Теперь
создавая детей ориентируемся на него, а не на interface Group<in T>. И все наследники
от "type-projection Group<out Dog>" будут принимать НЕ МЕНЬШЕ своего родителя, потому
что родитель вообще не принимает ничего 'fun insert(item: Nothing)', а наследники
могут принимать все что угодно, например:

class MyDog : Dog()

interface Group<MyDog> : Group<out Dog> {
	fun insert(item: MyDog): Unit
	fun fetch(): MyDog
}

То есть везде где ранее использовался ролитель Group<out Dog> мы можем подставить Group<MyDog>.


