why Kotlin won’t let you use a type parameter as an argument when it’s marked as out?

Терминология:
---------------

 type parameter: <T>
 type argument: <Dog>


Generics and Subtypes
---------------------

Основная трабла при работе с дженериками - это subtyping у производных от дженериков ТИПОВ.


Аналогии с обычными классами и интерфейсами:


Subtyping у обычных классов и интерфейсов определяется типами аргументов open-функций (argeumnt type) и 
типами возвр значений open-функций (return type). Набор всех argeumnt type класса/интерфейса говорит о том,
что конкретно он может ПРИНИМАТЬ, набор всех return type говорит о том, что конкретно он может ОТДАВАТЬ.

Теперь проведем аналогию с дженериком. У дженерика просто есть набор type parameters и это то, что он может
как принимать так и отдавать: все зависит от прототипов его open-функций. 

interface Generic<T, R> {
    fun insert(t: T): Unit
    fun fetch(): R
}

Для того чтобы строить subtyping на базе производных от дженериков ТИПОВ необходимо однозначно сказать 
компилятору роль каждого type parameter'а дженерика. Это необходимо, чтобы следовать 2-м правилам subtyping'а
и можно сделать как в месте декларации самого дженерика (Declaration-Site Variance), так и в месте, где
производный от дженерика ТИП фигурирует в качества аргумента какой-то функции (Use-Site variance).

interface Generic<in T, out R> {
    fun insert(t: T): Unit
    fun fetch(): R
}


Разбор полетов:
---------------

interface Group<T> {
	fun insert(item: T): Unit
	fun fetch(): T
}

И его проивзодные типы на базе иерархии Animal'ов.


Covariance
-----------

ПОТРЕБИТЕЛЬ группы - некий доктор ветеринар. Принимает всех животных - Group<Animal>, а значит и собак - Group<Dog>.
То есть мы хотим, чтобы Group<Dog> была подтипом от Group<Animal>.

Просто запишем эти два производных типа и посмотрим на них:


interface Group<Animal> {
	fun insert(item: Animal): Unit
	fun fetch(): Animal
}

interface Group<Dog> {
	fun insert(item: Dog): Unit
	fun fetch(): Dog
}

Видно, что Group<Dog> отдает НЕ БОЛЬШЕ (OK), но принимает МЕНЬШЕ (Error). То есть subtyping НЕ работает. Чо делать ?
Так как доктор - это потребитель, то можно убрать из Group<T> функцию ЗАПИСИ insert(...):

interface Group<T> {
	fun fetch(): T
}

На базе такого дженерика subtyping заработает, только нужно компилятору сказать, что мы хотим subtyping:

interface Group<out T> {
	fun fetch(): T
}

и теперь Kotlin знает, что Group<Dog> можно трактовать как subtype от Group<Animal> и будет проверять, чтобы
мы не добавили в дженерик функцию ЗАПИСИ, где <T> будет стоять в позиции аргумета функции.

Contravariance
----------------

Теперь у нас есть волонтер, который ПРИНОСИТ собак чтобы поместить их в приют собак - Group<Dog>, но если
будет приют вообще для всех животных - Group<Animal>, то и туда можно. То есть у нас ПРОИЗВОДИТЕЛЬ собак,
который ЗАПИСЫВАЕТ в Group<Dog>, но может ЗАПИСЫВАТЬ и в Group<Animal>. Мы хотим, чтобы Group<Animal> была
subtype'ом Group<Dog>.

Просто запишем эти два производных типа и посмотрим на них:

interface Group<Dog> {
	fun insert(item: Dog): Unit
	fun fetch(): Dog
}

interface Group<Animal> {
	fun insert(item: Animal): Unit
	fun fetch(): Animal
}

Видно, Group<Animal> ПОЛУЧАЕТ НЕ МЕНЬШЕ (OK), но ОТДАЕТ БОЛЬШЕ (Error). Учитывая, что волонтер только ПОСТАВЛЯЕТ
собак, то можно убрать из дженерика функцию чтения и все будет ОК. Нужно только компилятору сказать, что
мы хотим строить на базе дженерика КОНТРвариантый subtyping.

interface Group<in T> {
	fun insert(item: T): Unit
}

Это все зашибись, но что делать если мы на базе одного дженерика хотим получить и Covariance и Contravariance ?

Итак, Kotlin позволяет использовать GENERIC SUBTYPING в ДВУХ вариантах:

1. Declaration-site variance - это когда мы сразу при декларации дженерика накладываем ограничения на область
   применения его type parameter'ов, например <out T>
2. Use-site variance - это когда мы накладываем ограничения на область применения его type ARGUMENT'ов в месте
   использования ИНСТАНСА на базе дженерика - и именно здесь включается механизм 'Type Projection'.
   
Вариант 1: (в этом случае Kotlin будет следить, чтобы T не появилась в неправильной позиции)

interface Group<out T> {
	fun fetch(): T
}

Вариант 2 (Type Projection).

fun printInfo(group: Group<out Dog>) {
	println(group.fetch())
}   

Type Projection - это автоматически генерируемый тип, определенным образом ограниченный, чтобы соблюдались ОБА
правила subtyping'а. Projection - это как проекция. Например тень 3-х мерного объекта на стене - вроде похоже,
но не совсем то )) Так и с типом - часть возможностей становятся недоступны, отключены. Тип, сгенеренный с помощью
Type Projection, работает только в области видимости переменной к которой он относится.



