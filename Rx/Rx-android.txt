Самое главное в RX - вовремя отписаться.
========================================

Как выглядит Observable изнутри:
--------------------------------

Создаваемому Observable нужно передать функцию, которая будет генерить данные для подсписчиков.
Функция передается в виде инстанса Observable.OnSubscribe. Как только появится новый подсписчик, то
сразу будет вызвана Observable.OnSubscribe.call(subscriber) и работа начнется.

	Observable.OnSubscribe<Integer> onSubscribe = new Observable.OnSubscribe<Integer>() {
		@Override
		public void call(Subscriber<? super Integer> subscriber) {
			for (int i = 0; i < 10; i++) {
			
				.......

				subscriber.onNext(i);
			}
			subscriber.onCompleted();
		}
	};

	Observable<Integer> observable = Observable.create(onSubscribe)
	observable.subscribe(subscriber)
	

Как работает цепочка операторов:
--------------------------------

Observable.just("1", "2", "3", "4", "5").map{ }.filter{ }.subscribe(someSubscriber)

Каждый оператор - это новый Observable, который включает в себя предыдущий. Получается матрешка. Например для примера выше:

- создается начальный Observable с помощью Observable.just. Назовем его SourceObservable.
- Далее на SourceObservable вызывается map. Создается новый MapObservable со ссылкой на SourceObservable как на источник данных.
- Далее на MapObservable вызывается filter и создается FilterObservable со ссылкой на MapObservable как на источник данных.
- А потом выполняется подписка на FilterObservable и по цепочке доходит до SourceObservable в котором стартует 
  Observable.OnSubscribe.call(mapObservable as Observer)

У FilterObservable подписчиком является someSubscriber, а у SourceObservable - MapObservable. Код Observable.OnSubscribe.call()
внутри SourceObservable начнет работать в том же потоке, что и FilterObservable.subscribe(someSubscriber).

---------------------------------------------------------------------------------------------------------------------------------

В обязанности Observable входит проверять статус подписчика, и если он отписался, то не слать ему более никаких событий.
А подписчик, со своей стороны должен отписываться, если данные ему больше не нужны. Иначе Observable будет хранить 
ссылку на подписчика и это может привести к утечке памяти, т.к. подписчик может запросто хранить неявную ссылку на Activity.

При подключении нового наблюдателя будет заново запущена лямда .create{...}, то есть данные для нового подписчика
будут генериться заново.


Пример правильно написанного Observable:
----------------------------------------

        Observable.create<Int> { consumer ->

            (0..10).toList().forEach { i ->
                if(!consumer.isDisposed) consumer.onNext(i)
                else return@create
            }
            if(!consumer.isDisposed) consumer.onComplete()
        }


Cold Observable - это Observable описанный выше. Ничего не генерит пока нет подписчика.
---------------

Hot Observable - создается из Cold Observable методом 
---------------

	val hotObs = coldObs.publish()

Фактически coldObs в методе publish() создаст ещё один Observable, поместит в него ссылку на себя и вернет в val hotObs.
Теперь на hotObs мы можем выполнить метод hotObs.connect(), который внутри hotObs сделает coldObs.subscribe() и начнется эмиссия данных.
Теперь hotObs просто ретранслирует слева вправо всю эмиссию от coldObs всем своим подписчикам.

Вместо publish() можно использовать replay(). Тогда новые подписчики получат данные с самого начала. Для такого функционала 
используется кэширование (Внимательно !)








