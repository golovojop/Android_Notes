Три дерева GIT'а
-----------------------

1. 	Working directory - это рабочий каталог, его файлы и их контент. Изменение контента постоянно отслеживается гитом (возможно через OS API).
	Изменения контента - это изменения содержимого файлов, набора каталогов, то есть это изменения в файловой системе.
	
2.	Stages area или Indexes или Раздел проиндексированных файлов. Можно сказать, что это промежуточный буфер между
	файловой системой и деревом комитов. Я представляю себе это следующим образом: гит хранит контент файлов и хэши каждого файла.
	Если файл меняется, то гит узнает об этом от файловой системы (дерево 1), однако не пересчитывает хэш до того момента
	пока не получит команду add. Получив команду новый контент сохраняется, хэширутся (индексируется) и доступен для коммита. В коммит попадают только
	проиндексированные изменения.

3.	История коммитов. Хранит содержимое Раздела проиндексированных файлов на момент коммита (Получается, что и контент файлов тоже там хранится).
	Если точнее, то каждый коммит включает в себя
	- файл самого коммита
	- файл снепшота состояния дерева каталогов внутри working direstory на момент коммита
	- снепшоты всех файлов программы (контент + SHA1)
	

 edit                   edit
-------------stage1------------------stage2---- commit
    git add                  git add           <master>
                                                <HEAD>  
	
	
Нельзя откатить контент файла из состояния stage2 в состояние stage1. Можно только вывести файл из индекса, но контент его не изменится.


HEAD указывает на текущую ветку. Однако может быть ситуация, когда HEAD указывает на какой-то коммит, а не на ветку.
Вот так можно сделать "git checkout f573333" (где f573333 - номер коммита) и получим это состояние.
А если сделать вот так "git checkout master" то вернем HEAD на master. 

Кстати такой момент. Например у меня есть 2 ветки: master и branch1 и в каждой из них файл file2.txt со своим контентом (в каждом свой).
Допустим я перешел в branch1, там изменил содержимое внутри file2.txt, не добавился в индекс и пытаюсь перейти в master. Гит обнаружит
конфликт и не даст перейти. Я остаюсь в branch1. Теперь я добавляю изменения file2.txt в индекс и снова пытаюсь попасть в master. Снова
не получается по той же причине. И только после того как я закомичу file2.txt в ветке branch1 я смогу перейти в мастер. Файлы в обоих
ветках разные но конфликта нет. А вот если я буду мержить из branch1, то будет явный конфликт.

По веткам
============

Следует различать Удалённые ссылки и Ветки слежения. Это разные вещи. Удалённые ссылки (от слова "удаленно") это метки на коммиты
в удаленной репо. (А проще - это ветки в удаленных репо. И все.) Контент и индекс и история комитов находятся на сервере.
А Ветка слежения - это локальная ветка, точнее локальный клон удаленной ветки. Помимо указателя она включает в себя и контент
и индекс и историю коммитов. Однако мы не можем перемещать Ветку слежения по коммитам. Git перемещает её автоматически при любой
коммуникации с удаленным репозиторием.

Список удаленных сслылок (веток)
git ls-remote <remote>
git remote show <remote>


git remote [-v] - просмотр удаленных репозиториев. Кстати, локальный репо можно настроить на работу с несколькими удаленными
репозиториями !!! Например, в каждой из них своя программа и переключаясь между ветками разных репо можно работать над несколькими
программами по очереди.


Пример работы с удаленным репо:

1. Создаем пустую локальную репо и делаем в ней
git init

2. Добавляем две удаленных репы и называем их izitls и snadbox
git remote add izitls https://github.com/ciscoff/izibook_tls.git
git remote add snadbox https://github.com/ciscoff/IzISandbox.git

2. Теперь можно прочитать инфу про них
git fetch izitls

3. Посмотреть какие есть ветки на удаленной репе
git remote show izitls

4. Переключиться на нужную ветку для работы в ней. Создаем локальную ветку слежения izitls_master и клоним в неё удаленную. Ву аля !
git checkout -b izitls_master izitls/master

Теперь можно открыть студию и запустить проект.

5. А если сделать так
git checkout -b snadbox_master snadbox/master

то в студии появится другой проект. И это все внутри одной локальной репы, которая следит за двумя удаленными. 



==========================================================================================================================


git init - создание пустого репо
git clone - клонирует удаленную репо в локальную папку

git add - обновляет индексы на основе текущего контента рабочей директории. Создается stage для включения в следующий commit
		Можно выборочно stage'ить отдельные файлы и тогда только их изменения попадут в следующий commit. Индекс хранис снэпшот
		контента рабочей директории и этот снэпшот оставит следующий коммит.
		
git stash - позволяет временно сохранить все изменения, сделанные после последнего коммита в "отдельном месте" и откатиться к состоянию
		после последнего коммита.
       
	   
git restore <file> - удаляет изменения в файле, которые сделаны после последнего stage

get reset <commit num> - перемещает и указатель ветки (master например) и указатель HEAD на коммит num
	Однако есть варианты использования. См https://www.atlassian.com/ru/git/tutorials/undoing-changes/git-reset
	
	Нужно заметить, что если в рабочем каталоге есть непроиндексированные файлы, то на них манипуляции с гитом
	влияния не оказвывают. Такие файлы не удаляются даже если мы reset'ом пересоздаем содержимое рабочего каталога.

gei log [--oneline] [--graph] [--all] - показывает историю коммитов. Последовательность stage он не показывает.

git ls-files -s - просмотр состояния раздела проиндексированных файлов

git status - отображает различия между историей коммитов и разделом проиндексированных файлов

git branch -D <local-branch> - удаление локальной ветки


==========================================================================================================================

Пример workflow
-------------------

NOTE: patch - это разница между коммитами. Изменения которые между ними произошли.
	
- просмотреть локальные ветки
git branch 

- текущее состояние
git status <-s>

- что изменил, но не приндексировал
git diff (без аргументов)

- что проиндексировал и что войдет в коммит
git diff --staged
	или
git diff --cached 

- сразу все индексируем и коммитим
git commit -a -m 'мой коммент'

- удаление файла из гита (файл, который уже присутствует в коммитах): нужно не просто удалить файл с диска, но и проиндесировать это событие, а затем закомитить.
  удаление с индексацией делает команда
git rm <file>  

- удаление файла из гита (файл, который только staged, но ещё не присутствует в коммитах):
git rm -f <file>  

- просмотреть историю коммитов
git log <опции>

git log --pretty=oneline

git log --pretty=oneline --graph

Если нужно что-то отменить:
---------------------------

Например поторопился с коммитом и нужно ещё что-то добавить. Тогда добавляем в код то что нужно, а затем:

git commit --amend

NOTE: при этом нужно помнить, что мы полностью заменяем последний коммит. Его как бы не было.


Работа с удаленным репо: 
------------------------

NOTE: Мы можем настроить себе одновременно сразу несколько удаленных репо и переключаться между ними. 
Вообще мы как бы имеем список закладок на репы и локальная репа - частный случай одной из них.

Способы подключить себе удаленную репу:

git clone [https://github.com/ciscoff/hehe.git]
git remote add  hehe https://github.com/ciscoff/hehe.git


- Просмотреть какие имеем удаленные репы:
git remote

- Просмотреть адреса для чтения и записи, привязанные к репам
git remote -v

- Посмотреть инфу по конкретной удаленной репе:
git remote show origin

- Получение изменений из удалённого репозитория
git fetch [remote-name]  (Теперь имеем ссылки на все ветки из этого удалённого проекта)

Отправка изменений в удаленный репо в конкретную ветку (master)
git push origin master























