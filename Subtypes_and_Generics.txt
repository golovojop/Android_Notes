Subtype не должен ничего поломать. А именно, subtype должен принимать НЕ МЕНЬШЕ родителя
и отдавать НЕ БОЛЬШЕ родителя. То есть для внешнего мира он должен выглядеть как родитель.

Всегда нужно помнить, что КЛАСС это не есть тип когда дело касается дженериков.
Дженерик становится типом только после того как указаны КОНКРЕТНЫЕ ТИПЫ для
всех его type parameters. Тип можно указать просто, например <Animal>, или с использованием
type-projection, например <in Dog>, или <out Cat> или вообще <*>. 
Type-projection - это ТИП.

И вот только после того как мы создали типы можно говорить об отношениях "type <- subtype".
Дженерики ИНВАРИАНТНЫ, то есть до тех пор пока у нас есть только

interface Group<T> {
	fun insert(item: T): Unit
	fun fetch(): T
}

говорить о какой-то наследственности от Group бессмысленно потому что не определено 
на базе каких конкретных T эту наследственность строить.


P.S.

declaration-site variance
--------------------------

Это когда в момент ДЕКЛАРИРОВАНИЯ дженерика мы сразу накладываем ограничения на вариантность
его будущих инстансов.
Например:

interface Group<in T> {
	insert(item: T): Unit
}

use-site variance
-----------------

Это когда ограничения на вариантность накладываются в точке использования дженерика. И в этой точке компилятор
сгенерит "новый" subtype для Group<T>

Например указываем в коде: 
fun read(group: Group<out Dog>) = println(group.fetch())

и компилятор генерит подтип такого вида:

interface Group<out Dog> {
	fun insert(item: Nothing): Unit
	fun fetch(): Dog
}

В итоге group (аргумент функции read) имеет тип "type-projection Group<out Dog>"
