Билдер корутины
---------------

fun builderProc(op : (Any) -> Unit) : Job


Continuation
=============

Корутина упаковывается в Continuation-класс: это просто наследник интерфейса SuspendLambda.
Код, указанный выше как параметр билдера ( op: ...), попадет внуть invokeSuspend. 

interface SuspendLambda {
	fun invokeSuspend(any : Any?)
}

Общий вид алгоритма (в Java):
-----------------------------

Прототип suspend-функции: fun suspendProc(..., c: SuspendLambda)


int label = 0;

void invokeSuspend(Object result) {
    switch (label) {
        case 0: {
            label = 1;
 
            suspendProcA(..., this); 	// suspend function
            return;
        }
        case 1: {
            label = 2;
 
	    suspendProcB(..., this); 	// suspend function
            return;
        }
        case 2: {
            toast("OK");
            return;
        }
    }
}

Задача suspendProc - запустить какую-нибудь асинхронную работу (например, создать rx-подписку) и СРАЗУ вернуть управление.
Когда подписка сработает, то invokeSuspend будет вызвана снова, благодаря аргументу this в suspendProc. То есть invokeSuspend
вызывается НЕ рекурсивно, а последовательно, после того как сработает подписка очередной suspendProc. Получается такой
конвеер из suspendProc.

По уроку 4:
Получается, что invokeSuspend всегда вызывается из Continuation.resume. Даже самый первый раз.

По уроку 7
----------

Оказывается в Android Architecture components уже встроены элементы для поддержки корутин. 
В частности в LifeCyrcleOwner и ViewModel есть Scope'ы для корутин.

 ViewModel or LifeCyrcle
 -> SCOPE (ViewModelScope, LifecycleScope):
     -> Context
	-> JOB Parent
	  -> Job1
	  -> Job2
	  -> Job...

Также Scope можно создать самостоятельно.

По уроку 10.
-----------------------
Companion object внутри класса может быть именованным или нет.
ИМЯ КЛАССА, используемое САМО ПО СЕБЕ (а не как часть составного имени какого-нибудь qualifier'а),
действует как ссылка на companion object (именованного или неименованного). Ниже увидим пример, а также :
https://kotlinlang.org/docs/object-declarations.html#companion-objects

Теперь по корутинам. Context 'представляется' в виде Map'ы благодаря своему 'operator fun get'.

interface CoroutineContext
	operator fun <E : Element> get(key: Key<E>): E?
	operator fun plus(context: CoroutineContext): CoroutineContext

interface Element : CoroutineContext		
	==> Элемент Map'ы контекста

interface Key<E : Element>					
	==> Ключ Map'ы контекста. Однозначная привязка ТИПА ключа к ТИПУ элемента. То есть
		ключ конкрентного типа может относится только к элементу конкрентного типа.

interface Job : CoroutineContext.Element ==> Отдельный элемент, хранимый в Map'е

А вот реализация ключей и доступа к Map'е. Мы видим, что Job может храниться в Map'е, потому что
он является Element'ом. Также мы видим, что внутри Job задекларирован соответствующий Key
для него. А как говорилось выше, для ссылки на companion object мы можем использовать имя
внешнего класса, то найти Job в контексте можно вот так:

  val job = coroutineContext[Job]   Куль !!!

interface Job : CoroutineContext.Element {
	companion object Key : CoroutineContext.Key<Job> {
		. . . .
	}
}
	