Билдер корутины
---------------

fun Scope.builderProc(coroutineCode : Scope.(Any) -> Any) : Job

Билдер создаст новую Scope и на ней запустит код корутины, которые есть coroutineCode.

Continuation
=============

Корутина упаковывается в Continuation-класс: это просто наследник интерфейса SuspendLambda.
Код, указанный выше как параметр билдера ( op: ...), попадет внуть invokeSuspend. 

interface SuspendLambda {
	fun invokeSuspend(any : Any?)
}

Общий вид алгоритма (в Java):
-----------------------------

Прототип suspend-функции: fun suspendProc(..., c: SuspendLambda)


int label = 0;

void invokeSuspend(Object result) : Object {
    switch (label) {
        case 0: {
            label = 1;
 
            suspendProcA(..., this); 	// suspend function
            if(suspended) return COROUTINE_SUSPENDED	
        }
        case 1: {
            label = 2;
 
	    suspendProcB(..., this); 	// suspend function
            if(suspended) return COROUTINE_SUSPENDED	
        }
        case 2: {
            toast("OK");
            return result
        }
    }
}

Задача suspendProc - запустить какую-нибудь асинхронную работу (например, создать rx-подписку) и СРАЗУ вернуть управление.
Когда подписка сработает, то invokeSuspend будет вызвана снова, благодаря аргументу this в suspendProc. То есть invokeSuspend
вызывается НЕ рекурсивно, а последовательно, после того как сработает подписка очередной suspendProc. Получается такой
конвеер из suspendProc.

По уроку 4:
Получается, что invokeSuspend всегда вызывается из Continuation.resume. Даже самый первый раз.

По уроку 7
----------

Оказывается в Android Architecture components уже встроены элементы для поддержки корутин. 
В частности в LifeCyrcleOwner и ViewModel есть Scope'ы для корутин.

 ViewModel or LifeCyrcle
 -> SCOPE (ViewModelScope, LifecycleScope):
     -> Context
	-> JOB Parent
	  -> Job1
	  -> Job2
	  -> Job...

Также Scope можно создать самостоятельно.


Из чего состоит Context:
========================

-> Job (механизм иерархической связности корутин)
-> CoroutineDispatcher (выбор потока)
-> CoroutineName (строковое имя корутины)
-> CoroutineExceptionHandler (обработчик неперехваченных исключений.)


По уроку 10.
-----------------------
Companion object внутри класса может быть именованным или нет.
ИМЯ КЛАССА, используемое САМО ПО СЕБЕ (а не как часть составного имени какого-нибудь qualifier'а),
действует как ссылка на companion object (именованного или неименованного). Ниже увидим пример, а также :
https://kotlinlang.org/docs/object-declarations.html#companion-objects

Теперь по корутинам. Context 'представляется' в виде Map'ы благодаря своему 'operator fun get'.

interface CoroutineContext
	operator fun <E : Element> get(key: Key<E>): E?
	operator fun plus(context: CoroutineContext): CoroutineContext

interface Element : CoroutineContext		
	==> Элемент Map'ы контекста

interface Key<E : Element>					
	==> Ключ Map'ы контекста. Однозначная привязка ТИПА ключа к ТИПУ элемента. То есть
		ключ конкрентного типа может относится только к элементу конкрентного типа.

interface Job : CoroutineContext.Element ==> Отдельный элемент, хранимый в Map'е

А вот реализация ключей и доступа к Map'е. Мы видим, что Job может храниться в Map'е, потому что
он является Element'ом. Также мы видим, что внутри Job задекларирован соответствующий Key
для него. А как говорилось выше, для ссылки на companion object мы можем использовать имя
внешнего класса, то найти Job в контексте можно вот так:

  val job = coroutineContext[Job]   Куль !!!

interface Job : CoroutineContext.Element {
	companion object Key : CoroutineContext.Key<Job> {
		. . . .
	}
}
	
По уроку 11.
-----------------	

Нужно помнить, что  join(), await() и delay() - этот suspend-функции. То есть они запускают свой соновной код в каком-то потоке
и возвращают управление в родительскую корутину. Например такой код:

Loop@ scope.launch {

 val job1 = launch {...}
 val job2 = launch {...}
 
 job1.join()
 // return to Loop@
 
 job2.join()
 // return to Loop@
 
 ...some code

}

После первого join выходим из launch, НО СНОВА ВЕРНЕМСЯ когда job1 завершится. Вернувшись запускаем второй join и снова выходим из launch,
НО СНОВА ВЕРНЕМСЯ когда job2 завершится. Если job2 уже будет завершена к моменту завершения job1, то сразу проскочим вниз на 'some code'.
В общем каскад из нескольких join приводит к тому, что время его преодаления равно времени самого долгого job'а.


NOTE: Нужно отличать потоки в которых запускается и завершается сама корутина и потоки в которых выполня.тся suspend-функции.
Это вещи разные. Ниже описаны диспетчеры для потоков самих корутин.

Dispatchers.Default - пул потоков. Количество потоков равно количеству ядер процессора. Подходит для вычислений.

Dispatchers.IO - пул потоков. Лимит на потоки равен 64 (или числу ядер процессора, если их больше 64). Подходит для IO.

Отличие пулов в том, что можно одновременно запустить много IO операций и они в основном ждут. А вычислительные операции
херачат. Поэтому вычислительных операций должно быть мало, чтобы не засрать ЦП.

Dispatchers.Main - пул из одного MAIN-потока.

Dispatchers.Unconfined - такой диспетчер вообще не выполняет никаких переключений потоков. Корутина начинается
в потоке билдера и заказнчивается в потоке последней suspend-функции.

По уроку 12.
--------------

Код родительской корутины выполняется сразу и не ждет выполнения дочерней. Если родительская корутина выполнила весь свой код,
это еще не значит, что она завершена. Это зависит от того, завершились ли ее дочерние корутины. Именно в этом проявляется связь
между родительской и дочерней корутинами. Где это используется? Например - при отмене корутин. Вызов метода cancel для родительской
корутины каскадно отменит и все ее дочерние корутины. Но метод cancel сработает только для корутины, которая еще не завершена. 
	
Запуск дочерней корутины в режиме Lazy: не смотря на то, что такая дочерняя корутина не запускается сразу после создания, связь
между ней и родительской корутиной создается сразу и родительская корутина следит за состоянием этой связи. И теперь родительская
корутина не сможет завершиться пока и дочерняя не заверншится.

По уроку 13.
-------------

Метод resumeWith вызывает invokeSuspend. Этот вызов обернут в try-catch. И если код в invokeSuspend (т.е. код корутины) выбросит исключение,
то оно будет перехвачено и сохранено, как результат работы корутины. Continuation передает этот результат в Job. Тем самым он сообщает, 
что завершил выполнение своего кода. Job проверяет, что ему пришло на вход. Он сообщает об ошибке родителю. Родитель (в нашем случае) - это
Job в scope. Узнав о том, что в его дочерней корутине произошла ошибка, он отменяет себя, а также все свои дочерние корутины.
Т.е. - все корутины, созданные в этом scope. Далее Job корутины (не job scope'а) пытается самостоятельно обработать исключение, которое он 
получил из Continuation. Для этого он проверяет свой контекст, есть ли там объект CoroutineExceptionHandler.

Итак, при ошибке в одной из корутин отменяются все остальные активные корутины скоупа. Иногда это нежелательно и вместо Job() нужно 
использовать SupervisorJob(). Он отличается от Job() тем, что не отменяет всех своих детей при возникновении ошибки в одном из них.