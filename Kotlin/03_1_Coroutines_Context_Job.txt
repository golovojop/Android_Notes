interface CoroutineScope {
    val coroutineContext: CoroutineContext
}

interface CoroutineContext {

	interface Key<E : Element>
	
	interface Element : CoroutineContext {
		val key: Key<*>
	}
	
	. . . . прототипы методов для работы с элементами
}

Итак, CoroutineContext - это некое хранилище пар <Key, Element>

В свою очередь каждый Element - это тоже контекст. То есть контекст
является хранилищем других контекстов. Теперь смотрим сюда:

interface Job : CoroutineContext.Element {

	// Ключ для хранения Job внутри контекста. К companion object'у класса мы можем
	// обратиться по имени этого класса, а значит использовать ключ можно так: [Job]
	
	companion object Key : CoroutineContext.Key<Job> {...}

}

Job -->> Element -->> CoroutineContext

Job является элементом, а значит отдельным контекстом. То есть мы можем обратиться
к job'у как к контексту и по ключу [Job] 

------------------------------------------------------------------------

Coroutine => CoroutineScope (т.е. Context) + Job

Context -> хранилка + методы работы с хранимыми элементами.
Job -> состояние, подписки дочерних Job и пр.

coroutine.context[Job] == coroutine

Корутина в своем контексте по ключу [Job] хранит ссылку на саму себя как на Job.


