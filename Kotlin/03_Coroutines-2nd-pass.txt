0****************************************************************************************************
	Урок 1
****************************************************************************************************

Job
=====
Mожно запускать корутину внутри корутины. Их ДЖОБЫ будут СВЯЗАНЫ между собой отношениями PARENT-CHILD,
что является отдельным механизмом, который влияет на ОБРАБОТКУ ОШИБОК И ОТМЕНУ КОРУТИН.


КСТАТИ: SuspendLambda живет в пакете kotlin.coroutines.jvm.internal в файле ContinuationImpl.kt

****************************************************************************************************
	Урок 2 (https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-builders)
****************************************************************************************************


ПИПЕЦ !!!! (kotlin.coroutines.jvm.internal.ContinuationImpl.kt)

class SuspendLambda : ContinuationImpl {...}

	class ContinuationImpl : BaseContinuationImpl {...}
	
		class BaseContinuationImpl (completion : Continuation) : Continuation<Any?> {
		
			override fun resumeWith(result: Result<Any?>) {...}
			abstract fun invokeSuspend(result: Result<Any?>): Any?
			open fun create(value: Any?, completion: Continuation<*>): Continuation<Unit>
		}

Две последние функции вставляются компилятором в тот блок кода, который мы передаем в launch.
Получается, что этот блок кода становится инстансом BaseContinuationImpl ну и соответственно Continuation.

 =========================================================================================================

Далее подробности.


interface Job : CoroutineContext.Element {
	. . . .
}

interface CoroutineScope {
    val coroutineContext: CoroutineContext
}

interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}


NOTE: !!!!! Корутина реализует все эти три интерфейса ! То есть resumeWith(...) содержится в НЕЙ !


Рассмотрим работу билдера launch
--------------------------------

Существует такой класс как AbstractCoroutine, который является базовым для корутин, создаваемых билдерами,
и он имплементит три основных интерфейса. А именно:

 - Continuation
 - CoroutineScope
 - Job

То есть каждая созданная корутина является содержит context, имеет метод resumeWith(...),
а кроме этого является и Scope'ом и CoroutineContext'ом !!! Во как !

NOTE: Из AbstractCoroutine создаются LazyStandaloneCoroutine, StandaloneCoroutine и пр.

Билдер:
-------

fun CoroutineScope.launch(
	context: CoroutineContext, 
	start: CoroutineStart, 
	block: suspend CoroutineScope.() -> Unit): Job
	
Особый интерес здесь представляет третий аргумент 'suspend CoroutineScope.() -> Unit'. При компиляции это превращается в инстанс,
наследующий от SuspendLambda и от котлиновской версии Function2 (котлиновская Function2 вызывается через invoke).
В качестве this туда передается CoroutineScope. 

Итак, в общих чертах алгоритм такой: билдер, имея скоуп, context и start, создает инстанс корутины. Далее он инстанциирует 
лямду (она же Function2) и вызывает её Function2.invoke передавая аргументом корутину, которая является Continuation.
Внутри лямды происходит цепочка вызовов: invoke -> create -> invokeSuspend и работа пошла.

Теперь подробнее рассмотрим как это выглядит в байт коде:
---------------------------------------------------------

Это оболочка вокруг invokeSuspend внутри ревертированного Java-кода. Она не очень информативна:

Function2< CoroutineScope; Continuation; Object; > {

	public final invoke(Object; Object;) Object;	

	public final create(Object; Continuation;) Continuation;
	
	public final invokeSuspend(Object;) Object;
	
};

// Вот описание класса, который создается на базе лямды:
--------------------------------------------------------

// class signature 
	SuspendLambda; Function2<CoroutineScope; Continuation<Unit>; Object;>;

// class declaration (декларация анонимного класса на базе предыдущей сигнатуры)
	CoCoKt$main$1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object>

// Попробуем восстановить:

class CoCoKt$main$1 : SuspendLambda, Function2 {

	// Конструктор, вызывающий конструктор SuspendLambd'ы
	<init>(Continuation;) V
		call SuspendLambda.<init> (Continuation;) V

	public final invoke(var1 CoroutineScope; var2 Continuation;) Object;  ==>> Это Function2::invoke
		create(var1, var2).invokeSuspend

	public final create(var1 CoroutineScope; var2 Continuation;) Continuation;
		return var2
	
	public final invokeSuspend(Object;) Object;

}

Видно, что в конструкторе передается Continuation (он же корутина). Теперь этот Continuation можно будет отдавать
во внутренние вызовы suspend-функций.

NOTE: Остается неясным как resumeWith узнает адрес invokeSuspend'а, чтобы её вызывать.

// Далее пошаговый код её создания:
------------------------------------	
	
// Создаем Job скоупа и скоуп	
val job1 = INVOKESTATIC JobKt.Job$default (Job; Object;) CompletableJob;	
	checkcast (job == context) !!! Job - это CoroutineContext !!!
val scope = INVOKESTATIC CoroutineScope (CoroutineContext;) CoroutineScope;

// Это создается инстанс анонимного класса из блока кода для корутины (см класс выше)
val coroutine = NEW CoCoKt$main$1

call coroutine.constructor => INVOKESPECIAL CoCoKt$main$1.<init> (Continuation;)V
	checkcast (suspendLamda == Function2) ==>> Вот, лямда оборачивается в (SuspendLambda + Function2)

// И вот job самой корутины и её старт. Обрати внимание, что билдеру передается 
val job2 INVOKESTATIC BuildersKt.launch$default (CoroutineScope; CoroutineContext; CoroutineStart; Function2; Object;) Job;  	
		

++++++++++++++++++++++++++++++++

Вот цепочка вызовов. 

 
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    startOptions: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    val coroutine = StandaloneCoroutine(context, active = true)
    coroutine.start(startOptions, coroutine, block)
    return coroutine
}

 -->> launch создает корутину и стартует её, передавая наш block (который SuspendLambda + Function2) 

public fun <R> Coroutine::start(startOptions: CoroutineStart, receiver: R, block: suspend R.() -> T) {
    startOptions(block, receiver, this)
}

class CoroutineStart {

	operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
		block.startCoroutineCancellable(completion)
		
	fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
		createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
	}
}

public fun <T> (suspend () -> T).createCoroutineUnintercepted(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<kotlin.Unit> { /* compiled code */ }

****************************************************************************************************
	Урок 3 Suspend Functions
****************************************************************************************************

Каждая suspend функция получает первым, неявным, аргументом ссылку на enclosed Continuation. 
Через его resumeWith будет выполнен возврат результата.

suspend fun someProc(<implicit continuation: Continuation>, url: String): File { 
	return suspendCoroutine { continuation -> 
		. . . 
		continuation.resume(result)
		
		... или в случае ошибки ...
		
		continuation.resumeWithException(error)
	
	}
}

suspendCoroutine служит промежуточным звеном, поставляющим continuation внутрь кода нашей функции.

Создавая suspend функцию, мы должны позаботиться о том, чтобы она выполнялась асинхронно в другом потоке 
или вернула результат сразу. Если же мы напишем в suspend функции код, блокирующий поток, то слово suspend
нам никак не поможет. 

Если не вызвать никакой continuation.resume..., то корутина никогда не продолжится.

****************************************************************************************************
	Уроки 4 и 5. Возврат значения из Suspend-функции и в целом из корутины.
****************************************************************************************************

Итак, resume вызываетcя в двух случаях: 
	- для первого запуска корутины. 
	- из колбэков suspend-функций, когда они отработали.

Если resume вызвала функцию	invokeSuspend, то она ждет в ответ либо 'COROUTINE_SUSPENDED',
либо иное значение, которое будет означать завершение всей корутины и возврат результата.
Это то что касается вызовов ИЗ resume.

Когда вызывается сама resume, то свой аргумент она сразу передает далее в invokeSuspend
и ожидает два варианта результата (см выше).

class ContinuationImpl {

	void resume(Object result) {
		val result = invokeSuspend(result)
		
		// result: ЛИБО 'COROUTINE_SUSPENDED' ЛИБО конечный результат ВСЕЙ корутины
		
	}

	// В операторах 'case' нет ни break ни return. Значит если у suspend-функции результат готов сразу,
	// то просто переходим на следующий 'case' без возврата в resume.

                                                                                                                            -
	Object invokeSuspend(Object result) {
		switch (label) {
			case 0: {
				url = buildUrl();
				label = 1;
	 
				// Если функция download может сразу достать файл из кэша, то она не вызывает resume(file),
				// а просто возвращает это значение и код внутри invokeSuspend переходит на следующий case.
				result = download(url, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 1: {
				file = (File) result;
				toast("Url is downloaded: " + url);
				label = 2;
	 
				result = unzip(file, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 2: {
				size = (Long) result;
				toast("File is unzipped, size: " + size);
				return size;
			}
		}
	 
		throw new IllegalStateException("...");
	}
}

----------------------------------------
Вот примерный код suspend-функции, которая может вернуть результат из кэша.

Object download(String url, Continuation continuation) {
 
    File file = getFileFromCache(url);
	
	if(file == null) {
        networkService.download(url, new NetworkService.Callback() {
            @Override
            public void onSuccess(File result) {
                continuation.resume(result);
            }
 
            @Override
            public void onFailure(Exception error) {
                continuation.resumeWithException(error);
            }
        });	
		
		return COROUTINE_SUSPENDED;
	}
	
	return file
}
	
****************************************************************************************************
	Уроки 6
****************************************************************************************************	

Перед тем как метод invokeSuspend полностью завершится он меняет состояние корутины (внутри Job) на completed.


****************************************************************************************************
	Урок 7. Scope
****************************************************************************************************	

Scope - это корень иерархии корутин. Точнее его Job - корень иерархии Job'ов всех корутин скоупа.

public interface CoroutineScope {    
    // By convention, should contain an instance of a [job][Job] to enforce structured concurrency.
    public val coroutineContext: CoroutineContext
}

NOTE: смысл конструкции [job][Job]. Дело в том, что интерфейсы Job и CoroutineScope наследуются корутинами
через базовый класс AbstractCoroutine. И благодаря полиморфизму корутину можно представить как Job и как
CoroutineContext (подробнее в 03_1_Coroutines_Context_Job.txt)

Продолжим. В coroutineContext[Job] живет Job скоупа. У Scope свой собственный Job, который является корнем 
иерархии Job'ов всех корутин скоупа. Вообще иерархия Job'ов - это и есть реализация structured concurrency:
отменяем родительский Job и дочерние тоже отменятся.

Запуск дочерних корутин:

public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
)

Или как мы это делаем в коде программы:

scope.launch {
    // coroutine code block
}

Важный момент: между 'launch' и '{' из аргументов метода launch создается НОВЫЙ Scope со своим Job и на 
этом скоупе стартанет блок лямды. То есть внутри лямды будет свой скоуп в качестве this. И так происходит
во всех операторах launch. Везде 'между 'launch' и '{' создается новый скоуп с новым Job.

Очень хорошо про связи между скоупами контекстами и джобами рассказано здесь:
https://elizarov.medium.com/coroutine-context-and-scope-c8b255d59055

****************************************************************************************************
	Урок 8. Отмена корутины
****************************************************************************************************	

Выполняется через scope.cancel() или job.cancel(). В любом случае это просто меняет
статус Job'а на isActive == false. Код корутины продолжает делать свою работу. Поэтому
для остановки кода нужно в нем ЯВНО проверять статус isActive !!!

Однако, можно подписаться на событие отмены корутины и ориентироваться на него, а не на
проверку isActive. Так делают системные suspend функции (например delay). Свою suspend
функцию с подпиской нужно запускать не через suspendCoroutine, а через suspendCancellableCoroutine.

****************************************************************************************************
	Урок 9. Ожидание завершения корутины
****************************************************************************************************	

scope.launch {
 
   job = launch {
       // ...
   }
 
   // ...
   
   job.join()
}


join() - это suspend функция !!!


Когда создаются вложенные корутины, то родительская перейдет в статус Завершена ТОЛЬКО после того
как ВСЕ дочерние корутины будут завершены. Родительская корутина подписывается на дочерние и ждет
их завершения. Выполнение всего кода корутиной не означает что она завершена !!!

NOTE: join будет ждать, чтобы корутина была именно завершена, а не просто выполнила свой код. 
Соответственно, если у ожидаемой корутины есть дочерние, то он будет ждать пока они не завершатся (урок 12)


Результат из корутины:
----------------------

scope.launch {
 
   val deferred  = async {
       // ...
   }
 
   // ...
   
   val result = deferred.await()
}


await() - это suspend функция, deferred - наследник job.


Lazy
=====
Удобный механизм создать корутину и передать её job куда-то где она позже будет запущена 
на выполнение через job.start() !!!

NOTE: async-корутину также можно запускать в режиме Lazy. Метод await() стартует ее выполнение !!!

****************************************************************************************************
	Урок 10. Context
****************************************************************************************************	

public interface CoroutineScope {
   /**
    * The context of this scope.
    *
    * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.
    */
   public val coroutineContext: CoroutineContext
}

Я наконец-то обратил внимание на то, что переменная coroutineContext должна инстанциироваться либо ссылкой
на что-то, имплементирующее контекст, либо геттером, который тоже будет отдавать какой-то инстанс контекста.

Если например сделать так:

class CustomScope : CoroutineScope, Job {
	override val coroutineContext = this
	
	. . . . имплементация контекста
}

то CustomScope - есть и контекст и scope одновременно, потому что Job - это контекст. Ну да ладно.
Это я к тому, что скоуп - всегда контекст.

Размещение объекта кастомного класса в контексте:
-------------------------------------------------
data class UserData(
   val id: Long,
   val name: String,
   val age: Int
): AbstractCoroutineContextElement(UserData) {
   companion object Key : CoroutineContext.Key<UserData>
}

NOTE: По поводу Key напоминаю, что на companion object класса можно ссылкаться по имени класса,
то есть вот так: context[UserData]

Размещать свои классы в контексте удобно при передаче данных дочерним корутинам и корутинам своего уровня.

NOTE: Кстати диспетчер хранится в контексте по ключу [ContinuationInterceptor]. У скоупа может
не быть диспетчера потому что скоуп не выполняется. Это корутины выполняются и в их контекстах
всегда есть диспетчер. Однако если он есть в скоупе, то передается в контекст корутин вниз по цепочке.

Чтобы повлиять на содержимое контекста корутины, мы можем передать контекст в билдер этой корутины. 
Элементы этого контекста дополнят или заменят элементы переданные из родительской корутины или скопа.

****************************************************************************************************
	Урок 11. Dispatchers
****************************************************************************************************	

Тема оказалась важнее чем я думал. Итак, пул потоков можно представить себе как набор заранее
созданных инстансов в спящем состоянии, готовых проснуться, выполнить очередной блок кода и снова
заснуть. Диспетчеры пользуются такими пулами чтобы запускать в них отдельные корутины, а точнее -
методы invokeSuspend !!!

Стоит заметить, что диспетчер потоков назначается корутине, а не suspend-функции. Suspend-функция
всегда стартует на том потоке, который в данный момент у корутины.

Диспетчер Default и IO пользуются одним пулом. Диспетчеру Default разрешено брать оттуда количество
потоков, равное количеству ядер проца. Диспетчеру IO можно брать 64 потока или больше по кол-ву
ядер если их больше 64.

NOTE: Помни, что если suspend-функция внутри себя не переключится на новый поток, то она блокирнет поток
корутины и никакого suspend-эффекта не будет !!!

Нюансы:
--------

suspend fun getData() : Data {
	suspendCoroutine { con ->
		
		thread {
			val data = .....
			con.resume(data)
		}
		
	}
}

val scope = CoroutineScope(Dispatchers.Default)
 
scope.launch() {

	// Здесь будет, например, поток DefaultDispatcher-worker-1

   val data = getData(// Здесь будет какой-то Thread-5)
   
   // А вот здесь может быть какой-то DefaultDispatcher-worker-3

}

Завершая работу suspend-функция вызовет con.resume(data) в своем текущем потоке (Thread-5).
Далее должен последовать вызов invokeSuspend, но каждый такой вызов "проходит" через
диспетчер, который возьмет свободный поток из пула и передаст ему Continuation (то 
есть "ссылку" на invokeSuspend) на выполнение. И получается, что в процессе работы корутины
потоки могут постоянно меняться между case'ами внутри switch.

Однако, если у нас корутина стартует в диспетчере с одним потоком (MAIN), то этот поток и
будет везде внутри корутины.

И вот теперь можно рассмотреть диспетчер Unconfined. При его использовании:
- корутина стартует на том же потоке, на котором вызвался билдер.
- вызов invokeSuspend выполняется в том же потоке что и вызов continuation.resume().

То есть поток не меняется при возврате из suspend-функции. Например корутина стартует на потоке Main,
затем уходит в suspend, переключаясь на Thread-5. Suspend завершается вызывая con.resume(data)
на Thread-5 и следующий invokeSuspend тоже будет на Thread-5.

****************************************************************************************************
	Урок 12. Context. Связь Parent - Child.
****************************************************************************************************	

scope.launch { // parent coroutine
 
   launch(launchContext) { // child coroutine
 
   }
 
}

Билдер launch запускается на скоупе, у которого имеется coroutineContext. Кроме этого
в качестве аргумента билдер тоже принимает контекст. Внутри билдера эти два контекста
"плюсуются" и становятся единым РОДИТЕЛЬСКИМ контекстом для создаваемой корутины.

parent_context = scope_context + launch_context; 	// parent_context[Job] - это job скоупа
coroutine_context = parent_context + coroutine_job; // coroutine_context[Job] - это job корутины.

То есть у корутины фактически 2 контекста: свой и родительский. И между job'ами обоих
контекстов устанавливается связь в виде объекта ChildHandleNode:

child вызывает parent_context[Job].attachChild(coroutine_context[Job]) и получает
на выходе ChildHandleNode, который также сохраняется и в родительской Job.

Наличие такого объекта у родителя означает, что есть незавершенный child. А child 
через ChildHandleNode может разорвать связь вызовом ChildHandleNode.dispose и фактически 
удалив ChildHandleNode у родителя. Если родитель не имеет ChildHandleNode, значит у него
нет child'а.

Итак, ChildHandleNode - это связь между родителем и ребенком. Если у родителя есть
такой инстанс, значит у него есть ребенок. По другому он ребенка не видит.

1. Завершая работу дочерняя корутина вызывает ChildHandleNode.dispose, что приводит к 
удалению ChildHandleNode у родителя и больше для него данного ребенка не существует.

2. При завершении своей работы родительская корутина проверяет наличие у неё инстансов
ChildHandleNode. Если находит, то подписывается на ожидание окончания работы детей.




==========>>> Нужно дополнить про LAZY

****************************************************************************************************
	Уроки 13/14. Exceptions
****************************************************************************************************	

Вот так вот исключения корутины не ловятся:

private fun onRun() {
 
   try {
       scope.launch {
           Integer.parseInt("a")
       }
   } catch (e: Exception) {
       log("error $e")
   }
 
}

try/catch работает на стеке своего потока и в стековом контексте своей enclosed функции. А исключение
происходит в коде корутины, которая работает в отдельном потоке. Но даже если и в том же,
то у неё все равно иной стековый контекст вызова. try/catch нужно использовать непосредственно
в самой корутине, а не вокруг её билдера.

Когда в корутине происходит исключение, которое не обернуто в try-catch, мы получаем крэш ПРИЛОЖЕНИЯ !!!		

Как реализован вызов корутины:

class PseudoContinuation {
	val context : CoroutineContext = ...
	
	fun resumeWith(...) {
		
		try {
		
			invokeSuspend(...)
		
		} catch (exception: Exception) {
		
			context[Job].result = exception
			
			// Далее:
			// - Job сразу отменит себя и все свои дочерние корутины.
			// - Job сообщит родительской Job об ошибке и спросит может ли та обработать её.
			// - Если родитель не Scope, то он ответит ДА. Если Scope, то ответит НЕТ.
			// - При ответе ДА от родителя корутина завершается. И все.
			// - При ответе НЕТ - тоже завершается и пытается сама обработать
			//   исключение через context[CoroutineExceptionHandler]. Если 
			//   context[CoroutineExceptionHandler] существует, то все ОК, иначе крэш приложения.
			
		}
	}
}

Итак, ошибка всплывает снизу вверх к Job'у скоупа. Как только любой Job на пути всплытия узнаёт от нижнего
уровня об ошибке, то сразу отменяет свои дочерние корутины и ПОТОМ сообщает об ошибке выше. Только 
ПРЕДПОСЛЕДНЯЯ Job (корутина перед скоупом) попытается обработать исключение, потому что скоуп ей ответил НЕТ
(все транзитные Job'ы отвечают нижним ДА).

Когда ошибка доходит до Scope, то отменятся и весь скоуп и все его дочерние корутины. Это удобно, если
при возникновении ошибки в одной операции, надо отменить другие операции: просто помещаем корутины с этими
операциями в один scope. 

NOTE: Так как скоуп отменяет себя, то больше в нем нельзя запустить корутину !!!

NOTE: Разные scope никак не связаны между собой.

Чтобы Job при ошибке в одной дочерней корутине не отменял другие дочерние корутины нужно на
родительском уровне использовать не Job, а SupervisorJob.

NOTE: В обработчике CoroutineExceptionHandler мы на вход получаем ошибку и КОНТЕКСТ корутины,
которая ПЕРЕДАЛА ошибку в этот обработчик. Мы из контекста достаем CoroutineName и с его помощью узнаем,
какая корутина обработала ошибку. То есть обработчик знает кто ему передал, а не где на самом деле
был сбой.

Всплытие ошибки наверх:
-----------------------

Scope_Job  <<-- error, can_you_handle? <<-- Job_1  <<-- error, can_you_handle? <<-- Job_1_1 <!!! Exception !!!>
=========                                   ======                                  =======
      |                                         |
      +------------ NO, I can't handle --->>    +-------- YES, I can handle ------>>

И Job_1 должна обработать ошибку !!!