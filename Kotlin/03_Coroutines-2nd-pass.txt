NOTE: Аналогии с RX:
- Rx: CompositeDisposable --->> Coroutine: Scope

****************************************************************************************************
	Урок 1
****************************************************************************************************

Job
=====
Mожно запускать корутину внутри корутины. Их ДЖОБЫ будут СВЯЗАНЫ между собой отношениями PARENT-CHILD,
что является отдельным механизмом, который влияет на ОБРАБОТКУ ОШИБОК И ОТМЕНУ КОРУТИН.

КСТАТИ: SuspendLambda живет в пакете kotlin.coroutines.jvm.internal в файле ContinuationImpl.kt

****************************************************************************************************
	Урок 2 (https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-builders)
****************************************************************************************************


ПИПЕЦ !!!! (kotlin.coroutines.jvm.internal.ContinuationImpl.kt)

class SuspendLambda : ContinuationImpl {...}

	class ContinuationImpl : BaseContinuationImpl {...}
	
		class BaseContinuationImpl (completion : Continuation) : Continuation<Any?> {
		
			override fun resumeWith(result: Result<Any?>) {...}
			abstract fun invokeSuspend(result: Result<Any?>): Any?
			open fun create(value: Any?, completion: Continuation<*>): Continuation<Unit>
		}

Две последние функции вставляются компилятором в тот блок кода, который мы передаем в launch.
Получается, что этот блок кода становится инстансом BaseContinuationImpl ну и соответственно Continuation.

=========================================================================================================

Далее подробности.


interface Job : CoroutineContext.Element {
	. . . .
}

interface CoroutineScope {
    val coroutineContext: CoroutineContext
}

interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}


NOTE: !!!!! Корутина реализует все эти три интерфейса ! То есть resumeWith(...) содержится в НЕЙ !

И получается вот такая штука - два контекста !!! Видимо один родительский, второй - сплюсуется с ним,
образуя окончательный вариант родительского контекста для корутины.

class SomeCoroutine: CoroutineScope, Job, Continuation {
	override val coroutineContext: CoroutineContext
	override val context: CoroutineContext
	.....
}

Рассмотрим работу билдера launch
--------------------------------

Существует такой класс как AbstractCoroutine, который является базовым для корутин, создаваемых билдерами,
и он имплементит три основных интерфейса. А именно:

 - Continuation
 - CoroutineScope
 - Job

То есть каждая созданная корутина содержит context (2 контекста, см .выше), имеет метод resumeWith(...),
а кроме этого является и Scope'ом и CoroutineContext'ом !!! Во как !

NOTE: Из AbstractCoroutine создаются LazyStandaloneCoroutine, StandaloneCoroutine и пр.

Билдер:
-------

fun CoroutineScope.launch(
	context: CoroutineContext, 
	start: CoroutineStart, 
	block: suspend CoroutineScope.() -> Unit): Job
	
(NOTE: receiver CoroutineScope предоставит родительский контекст, а аргумент context сплюсуется
с родительским образуя окончательный родительский контекст для корутины)
	
Особый интерес здесь представляет третий аргумент 'suspend CoroutineScope.() -> Unit'. При компиляции это превращается в инстанс,
наследующий от SuspendLambda и от котлиновской версии Function2 (котлиновская Function2 вызывается через invoke).
В качестве this туда передается CoroutineScope. 

Итак, в общих чертах алгоритм такой: билдер, имея родительский скоуп (ресивер), context и start, создает инстанс корутины. 
Далее он инстанциирует лямду (она же Function2) и вызывает её Function2.invoke, передавая аргументом корутину, которая 
является Continuation.
Внутри лямды происходит цепочка вызовов: invoke -> create -> invokeSuspend и работа пошла.

Теперь подробнее рассмотрим как это выглядит в байт коде:
---------------------------------------------------------

Это оболочка вокруг invokeSuspend внутри ревертированного Java-кода. Она не очень информативна:

Function2< CoroutineScope; Continuation; Object; > {

	public final invoke(Object; Object;) Object;	

	public final create(Object; Continuation;) Continuation;
	
	public final invokeSuspend(Object;) Object;
	
};

// Вот описание класса, который создается на базе лямды:
--------------------------------------------------------

// class signature 
	SuspendLambda; Function2<CoroutineScope; Continuation<Unit>; Object;>;

// class declaration (декларация анонимного класса на базе предыдущей сигнатуры)
	CoCoKt$main$1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object>

// Попробуем восстановить:

class CoCoKt$main$1 : SuspendLambda, Function2 {

	// Конструктор, вызывающий конструктор SuspendLambd'ы
	<init>(Continuation;) V
		call SuspendLambda.<init> (Continuation;) V

	public final invoke(var1 CoroutineScope; var2 Continuation;) Object;  ==>> Это Function2::invoke
		create(var1, var2).invokeSuspend

	public final create(var1 CoroutineScope; var2 Continuation;) Continuation;
		return var2
	
	public final invokeSuspend(Object;) Object;

}

Видно, что в конструкторе передается Continuation (он же корутина). Теперь этот Continuation можно будет отдавать
во внутренние вызовы suspend-функций.

NOTE: Остается неясным как resumeWith узнает адрес invokeSuspend'а, чтобы её вызывать.

// Далее пошаговый код её создания:
------------------------------------	
	
// Создаем Job скоупа и скоуп	
val job1 = INVOKESTATIC JobKt.Job$default (Job; Object;) CompletableJob;	
	checkcast (job == context) !!! Job - это CoroutineContext !!!
val scope = INVOKESTATIC CoroutineScope (CoroutineContext;) CoroutineScope;

// Это создается инстанс анонимного класса из блока кода для корутины (см класс выше)
val coroutine = NEW CoCoKt$main$1

call coroutine.constructor => INVOKESPECIAL CoCoKt$main$1.<init> (Continuation;)V
	checkcast (suspendLamda == Function2) ==>> Вот, лямда оборачивается в (SuspendLambda + Function2)

// И вот job самой корутины и её старт. Обрати внимание, что билдеру передается 
val job2 INVOKESTATIC BuildersKt.launch$default (CoroutineScope; CoroutineContext; CoroutineStart; Function2; Object;) Job;  	
		

++++++++++++++++++++++++++++++++

Вот цепочка вызовов. 

 
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    startOptions: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    val coroutine = StandaloneCoroutine(context, active = true)
    coroutine.start(startOptions, coroutine, block)
    return coroutine
}

 -->> launch создает корутину и стартует её, передавая наш block (который SuspendLambda + Function2) 

public fun <R> Coroutine::start(startOptions: CoroutineStart, receiver: R, block: suspend R.() -> T) {
    startOptions(block, receiver, this)
}

class CoroutineStart {

	operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
		block.startCoroutineCancellable(completion)
		
	fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
		createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
	}
}

public fun <T> (suspend () -> T).createCoroutineUnintercepted(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<kotlin.Unit> { /* compiled code */ }

****************************************************************************************************
	Урок 3 Suspend Functions
****************************************************************************************************

Каждая suspend функция получает первым, неявным, аргументом ссылку на enclosed Continuation. 
Через его resumeWith будет выполнен возврат результата.

suspend fun someProc(<implicit continuation: Continuation>, url: String): File { 
	return suspendCoroutine { continuation -> 
		. . . 
		continuation.resume(result)
		
		... или в случае ошибки ...
		
		continuation.resumeWithException(error)
	
	}
}

suspendCoroutine служит промежуточным звеном, поставляющим continuation внутрь кода нашей функции.

Создавая suspend функцию, мы должны позаботиться о том, чтобы она выполнялась асинхронно в другом потоке 
или вернула результат сразу. Если же мы напишем в suspend функции код, блокирующий поток, то слово suspend
нам никак не поможет. 

Если не вызвать никакой continuation.resume..., то корутина никогда не продолжится.

NOTE: Вызвать suspend-функцию мы можем только в корутине или в другой suspend функции !!!

****************************************************************************************************
	Уроки 4 и 5. Возврат значения из Suspend-функции и в целом из корутины.
****************************************************************************************************

Итак, resume вызываетcя в двух случаях: 
	- для первого запуска корутины. 
	- из колбэков suspend-функций, когда они отработали.

Если resume вызвала функцию	invokeSuspend, то она ждет в ответ либо 'COROUTINE_SUSPENDED',
либо иное значение, которое будет означать завершение всей корутины и возврат результата.
Это то что касается вызовов ИЗ resume.

Когда вызывается сама resume, то свой аргумент она сразу передает далее в invokeSuspend
и ожидает два варианта результата (см выше).

class ContinuationImpl {

	void resume(Object result) {
		val result = invokeSuspend(result)
		
		// result: ЛИБО 'COROUTINE_SUSPENDED' ЛИБО конечный результат ВСЕЙ корутины
		
	}

	// В операторах 'case' нет ни break ни return. Значит если у suspend-функции результат готов сразу,
	// то просто переходим на следующий 'case' без возврата в resume.

                                                                                                                            -
	Object invokeSuspend(Object result) {
		switch (label) {
			case 0: {
				url = buildUrl();
				label = 1;
	 
				// Если функция download может сразу достать файл из кэша, то она не вызывает resume(file),
				// а просто возвращает это значение и код внутри invokeSuspend переходит на следующий case.
				result = download(url, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 1: {
				file = (File) result;
				toast("Url is downloaded: " + url);
				label = 2;
	 
				result = unzip(file, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 2: {
				size = (Long) result;
				toast("File is unzipped, size: " + size);
				return size;
			}
		}
	 
		throw new IllegalStateException("...");
	}
}

----------------------------------------
Вот примерный код suspend-функции, которая может вернуть результат из кэша.

Object download(String url, Continuation continuation) {
 
    File file = getFileFromCache(url);
	
	if(file == null) {
        networkService.download(url, new NetworkService.Callback() {
            @Override
            public void onSuccess(File result) {
                continuation.resume(result);
            }
 
            @Override
            public void onFailure(Exception error) {
                continuation.resumeWithException(error);
            }
        });	
		
		return COROUTINE_SUSPENDED;
	}
	
	return file
}
	
****************************************************************************************************
	Уроки 6
****************************************************************************************************	

Перед тем как метод invokeSuspend полностью завершится он меняет состояние корутины (внутри Job) на completed.


****************************************************************************************************
	Урок 7. Scope
****************************************************************************************************	

Scope - это корень иерархии корутин. Точнее его Job - корень иерархии Job'ов всех корутин скоупа.

public interface CoroutineScope {    
    // By convention, should contain an instance of a [job][Job] to enforce structured concurrency.
    public val coroutineContext: CoroutineContext
}

NOTE: смысл конструкции [job][Job]. Дело в том, что интерфейсы Job и CoroutineScope наследуются корутинами
через базовый класс AbstractCoroutine. И благодаря полиморфизму корутину можно представить как Job и как
CoroutineContext (подробнее в 03_1_Coroutines_Context_Job.txt)

Продолжим. В coroutineContext[Job] живет Job скоупа. У Scope свой собственный Job, который является корнем 
иерархии Job'ов всех корутин скоупа. Вообще иерархия Job'ов - это и есть реализация structured concurrency:
отменяем родительский Job и дочерние тоже отменятся.

Запуск дочерних корутин:

public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
)

Или как мы это делаем в коде программы:

scope.launch {
    // coroutine code block
}

Важный момент: между 'launch' и '{' из аргументов метода launch создается НОВЫЙ Scope со своим Job и на 
этом скоупе стартанет блок лямды. То есть внутри лямды будет свой скоуп в качестве this. И так происходит
во всех операторах launch. Везде 'между 'launch' и '{' создается новый скоуп с новым Job.

Очень хорошо про связи между скоупами контекстами и джобами рассказано здесь:
https://elizarov.medium.com/coroutine-context-and-scope-c8b255d59055

****************************************************************************************************
	Урок 8. Отмена корутины
****************************************************************************************************	

Выполняется через scope.cancel() или job.cancel(). В любом случае это просто меняет
статус Job'а на isActive == false. Код корутины продолжает делать свою работу. Поэтому
для остановки кода нужно в нем ЯВНО проверять статус isActive !!!

Однако, можно подписаться на событие отмены корутины и ориентироваться на него, а не на
проверку isActive. Так делают системные suspend функции (например delay). Свою suspend
функцию с подпиской нужно запускать не через suspendCoroutine, а через suspendCancellableCoroutine.

****************************************************************************************************
	Урок 9. Ожидание завершения корутины
****************************************************************************************************	

scope.launch {
 
   job = launch {
       // ...
   }
 
   // ...
   
   job.join()
}


join() - это suspend функция !!!


Когда создаются вложенные корутины, то родительская перейдет в статус Завершена ТОЛЬКО после того
как ВСЕ дочерние корутины будут завершены. Родительская корутина подписывается на дочерние и ждет
их завершения. Выполнение всего кода корутиной не означает что она завершена !!!

NOTE: join будет ждать, чтобы корутина была именно завершена, а не просто выполнила свой код. 
Соответственно, если у ожидаемой корутины есть дочерние, то он будет ждать пока они не завершатся (урок 12)


Результат из корутины:
----------------------

scope.launch {
 
   val deferred  = async {
       // ...
   }
 
   // ...
   
   val result = deferred.await()
}


await() - это suspend функция, deferred - наследник job.


Lazy
=====
Удобный механизм создать корутину и передать её job куда-то где она позже будет запущена 
на выполнение через job.start() !!!

NOTE: async-корутину также можно запускать в режиме Lazy. Метод await() стартует ее выполнение !!!

****************************************************************************************************
	Урок 10. Context
****************************************************************************************************	

public interface CoroutineScope {
   /**
    * The context of this scope.
    *
    * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.
    */
   public val coroutineContext: CoroutineContext
}

Я наконец-то обратил внимание на то, что переменная coroutineContext должна инстанциироваться либо ссылкой
на что-то, имплементирующее контекст, либо геттером, который тоже будет отдавать какой-то инстанс контекста.

Если например сделать так:

class CustomScope : CoroutineScope, Job {
	override val coroutineContext = this
	
	. . . . имплементация контекста
}

то CustomScope - есть и контекст и scope одновременно, потому что Job - это контекст. Ну да ладно.
Это я к тому, что скоуп - всегда контекст.

Размещение объекта кастомного класса в контексте:
-------------------------------------------------
data class UserData(
   val id: Long,
   val name: String,
   val age: Int
): AbstractCoroutineContextElement(UserData) {
   companion object Key : CoroutineContext.Key<UserData>
}

NOTE: По поводу Key напоминаю, что на companion object класса можно ссылкаться по имени класса,
то есть вот так: context[UserData]

Размещать свои классы в контексте удобно при передаче данных дочерним корутинам и корутинам своего уровня.

NOTE: Кстати диспетчер хранится в контексте по ключу [ContinuationInterceptor]. У скоупа может
не быть диспетчера потому что скоуп не выполняется. Это корутины выполняются и в их контекстах
всегда есть диспетчер. Однако если он есть в скоупе, то передается в контекст корутин вниз по цепочке.

Чтобы повлиять на содержимое контекста корутины, мы можем передать контекст в билдер этой корутины. 
Элементы этого контекста дополнят или заменят элементы переданные из родительской корутины или скопа.

****************************************************************************************************
	Урок 11. Dispatchers
****************************************************************************************************	

Тема оказалась важнее чем я думал. Итак, пул потоков можно представить себе как набор заранее
созданных инстансов в спящем состоянии, готовых проснуться, выполнить очередной блок кода и снова
заснуть. Диспетчеры пользуются такими пулами чтобы запускать в них отдельные корутины, а точнее -
методы invokeSuspend !!!

Стоит заметить, что диспетчер потоков назначается корутине, а не suspend-функции. Suspend-функция
всегда стартует на том потоке, который в данный момент у корутины.

Диспетчер Default и IO пользуются одним пулом. Диспетчеру Default разрешено брать оттуда количество
потоков, равное количеству ядер проца. Диспетчеру IO можно брать 64 потока или больше по кол-ву
ядер (если их больше 64).

NOTE: Помни, что если suspend-функция внутри себя не переключится на новый поток, то она БЛОКИРУЕТ (!!!)
поток корутины и никакого suspend-эффекта не будет !!!

Нюансы:
--------

suspend fun getData() : Data {
	suspendCoroutine { con ->
		
		thread {
			val data = .....
			con.resume(data)
		}
		
	}
}

val scope = CoroutineScope(Dispatchers.Default)
 
scope.launch() {

	// Здесь будет, например, поток DefaultDispatcher-worker-1

   val data = getData(// Здесь будет какой-то Thread-5)
   
   // А вот здесь может быть какой-то DefaultDispatcher-worker-3

}

Завершая работу suspend-функция вызовет con.resume(data) в своем текущем потоке (Thread-5).
Далее должен последовать вызов invokeSuspend, но каждый такой вызов "проходит" через
диспетчер, который возьмет свободный поток из пула и передаст ему Continuation (то 
есть "ссылку" на invokeSuspend) на выполнение. И получается, что в процессе работы корутины
потоки могут постоянно меняться между case'ами внутри switch.

Однако, если у нас корутина стартует в диспетчере с одним потоком (MAIN), то этот поток и
будет везде внутри корутины.

И вот теперь можно рассмотреть диспетчер Unconfined. При его использовании:
- корутина стартует на том же потоке, на котором вызвался билдер.
- вызов invokeSuspend выполняется в том же потоке что и вызов continuation.resume().

То есть поток не меняется при возврате из suspend-функции. Например корутина стартует на потоке Main,
затем уходит в suspend, переключаясь на Thread-5. Suspend завершается вызывая con.resume(data)
на Thread-5 и следующий invokeSuspend тоже будет на Thread-5.

Еще хотел добавить, что invokeSuspend каждый раз должен быть запущен не только на потоке из пула, но и 
тем же диспетчером. "Чужие" потоки (как например Thread-5 выше) не допускаются к запуску invokeSuspend.

****************************************************************************************************
	Урок 12. Context. Связь Parent - Child.
****************************************************************************************************	

scope.launch { // parent coroutine
 
   launch(launchContext) { // child coroutine
 
   }
 
}

Билдер launch запускается на скоупе, у которого имеется coroutineContext. Кроме этого
в качестве аргумента билдер тоже принимает контекст. Внутри билдера эти два контекста
"плюсуются" и становятся единым РОДИТЕЛЬСКИМ контекстом для создаваемой корутины.

parent_context = scope_context + launch_context; 	// parent_context[Job] - это job скоупа
coroutine_context = parent_context + coroutine_job; // coroutine_context[Job] - это job корутины.

То есть у корутины фактически 2 контекста: свой и родительский. И между job'ами обоих
контекстов устанавливается связь в виде объекта ChildHandleNode:

child вызывает parent_context[Job].attachChild(coroutine_context[Job]) и получает
на выходе ChildHandleNode, который также сохраняется и в родительской Job.

Наличие такого объекта у родителя означает, что есть незавершенный child. А child 
через ChildHandleNode может разорвать связь вызовом ChildHandleNode.dispose и фактически 
удалив ChildHandleNode у родителя. Если родитель не имеет ChildHandleNode, значит у него
нет child'а.

Итак, ChildHandleNode - это связь между родителем и ребенком. Если у родителя есть
такой инстанс, значит у него есть ребенок. По другому он ребенка не видит.

1. Завершая работу дочерняя корутина вызывает ChildHandleNode.dispose, что приводит к 
удалению ChildHandleNode у родителя и больше для него данного ребенка не существует.

2. При завершении своей работы родительская корутина проверяет наличие у неё инстансов
ChildHandleNode. Если находит, то подписывается на ожидание окончания работы детей 
(для этого она создает объект ChildCompletion и дает дочерней корутине). Далее дочерняя 
корутина, завершив работу, удаляет у родителя соответствующий ChildHandleNode
(через ChildHandleNode.dispose), проверяет есть ли подписка родителя в виде ChildCompletion
Если такая подписка есть, то через неё дочерняя сообщяает родителю о своем завершении.
Когда у родителя завершатся все ChildCompletion, то она тоже завершится.


NOTE: Запуск LAZY корутины:
---------------------------

Когда дочернюю запускаем через 'launch(start = CoroutineStart.LAZY)', НО не стартуем её сразу.
В этом случае запуск будет отложен до явного вызова start(), но связь ChildHandleNode
создается СРАЗУ. И это значит, что если не стартануть дочернюю, то связь никогда не прервется
и родитель всегда будет активным. Кроме того, если родитель сам является дочерним
и на нем где-то вызван join(), то этот код так и останется на месте !!!

Запуск через async()
--------------
Здесь по прежнему при создании дочерней корутины одновременно создается и связь в виде ChildHandleNode,
но в этом случае родитель ждет завершения ребенка и код ребенка, соответственно, всегда завершается
раньше родителя. Тут два варианта ожидания.

- у ребенка сразу готов результат. Ребенок завершается, удаляет ChildHandleNode и возвращает результат
  прямо из await(). Тогда все ОК и родитель продолжает работу.
- ребенку нужно поработать. В этом случае внутри кода await (которая есть suspend) берется родительский
  Continuation и подписывается на завершение работы ребенка. Ребенок по окончании работы проверяет
  такие подписки и анонсит через них свое окончание вместе с результатом.

****************************************************************************************************
	Уроки 13/14/15. Exceptions
****************************************************************************************************	

Вот так вот исключения корутины не ловятся:

private fun onRun() {
 
   try {
       scope.launch {
           Integer.parseInt("a")
       }
   } catch (e: Exception) {
       log("error $e")
   }
 
}

try/catch работает на стеке своего потока и в стековом контексте своей enclosed функции. А исключение
происходит в коде корутины, которая работает в отдельном потоке. Но даже если и в том же,
то у неё все равно иной стековый контекст вызова. try/catch нужно использовать непосредственно
в самой корутине, а не вокруг её билдера.

Когда в корутине происходит исключение, которое не обернуто в try-catch, мы получаем крэш ПРИЛОЖЕНИЯ !!!		

Как реализован вызов корутины:

class PseudoContinuation {
	val context : CoroutineContext = ...
	
	fun resumeWith(...) {
		
		try {
		
			invokeSuspend(...)
		
		} catch (exception: Exception) {
		
			context[Job].result = exception
			
			// Далее:
			// - Job сразу отменит себя и все свои дочерние корутины.
			// - Job сообщит родительской Job об ошибке и спросит может ли та обработать её.
			// - Если родитель не Scope, то он ответит ДА. Если Scope, то ответит НЕТ.
			// - При ответе ДА от родителя корутина завершается. И все.
			// - При ответе НЕТ - тоже завершается и пытается сама обработать
			//   исключение через context[CoroutineExceptionHandler]. Если 
			//   context[CoroutineExceptionHandler] существует, то все ОК, иначе крэш приложения.
			
		}
	}
}

Итак, ошибка всплывает снизу вверх к Job'у скоупа. Как только любой Job на пути всплытия узнаёт от нижнего
уровня об ошибке, то сразу отменяет свои дочерние корутины и ПОТОМ сообщает об ошибке выше. Только 
ПРЕДПОСЛЕДНЯЯ Job (корутина перед скоупом) попытается обработать исключение, потому что скоуп ей ответил НЕТ
(все транзитные Job'ы отвечают нижним ДА).

Когда ошибка доходит до Scope, то отменятся и весь скоуп и все его дочерние корутины. Это удобно, если
при возникновении ошибки в одной операции, надо отменить другие операции: просто помещаем корутины с этими
операциями в один scope. 

NOTE: Так как скоуп отменяет себя, то больше в нем нельзя запустить корутину !!!

NOTE: Разные scope никак не связаны между собой.

Чтобы Job при ошибке в одной дочерней корутине не отменял другие дочерние корутины нужно на
родительском уровне использовать не Job, а SupervisorJob.

NOTE: В обработчике CoroutineExceptionHandler мы на вход получаем ошибку и КОНТЕКСТ корутины,
которая ПЕРЕДАЛА ошибку в этот обработчик. Мы из контекста достаем CoroutineName и с его помощью узнаем,
какая корутина обработала ошибку. То есть обработчик знает кто ему передал, а не где на самом деле
был сбой.

Всплытие ошибки наверх:
-----------------------

Scope_Job  <<-- error, can_you_handle? <<-- Job_1  <<-- error, can_you_handle? <<-- Job_1_1 <!!! Exception !!!>
=========                                   ======                                  =======
      |                                         |
      +------------ NO, I can't handle --->>    +-------- YES, I can handle ------>>

И Job_1 должна обработать ошибку !!!


SupervisorJob:
---------------

Некоторые моменты по поводу Job'ов. Если сделать вот так:

scope.launch { 
 
   launch(Job()) {
 
   }
}

то Job, переданный в launch, станет РОДИТЕЛЬСКИМ для job'а корутины.  Возникнет
ситуация когда нет связи с job'ом скоупа:

'scope_job ... launch_job <-- child_job'

Это потому, что Job - это контекст, и фактически мы передаем в launch контекст,
который плюсуется с контекстом скоупа и замещает в нем элемент [Job]. В этом случае
job корутины установит связь не с job'ом скоупа, а с job'ом-аргументом билдера. 
И нарушится structured concurrency. Job скоупа вообще ни с кем не будет связан 
(и если отменить скоуп, то его дочерние корутины не отменятся). Это можно обойти 
костылем (см. урок 14 в конце).

Костыль, создающий связь 'scope_job <-- launch_job <-- child_job':

scope.launch { 
 
   launch(Job(coroutineContext[Job])) {
 
   }
}

NOTE: Вместо костыля можно использовать supervisorScope.

А теперь про SupervisorJob. Если её использовать на каком-то уровне вложенности корутин,
то, при всплытии ошибки на этот уровень, не будут отменены другие дочерние корутины ЭТОГО
уровня и ошибка НЕ ПОЙДЕТ выше. SupervisorJob всегда сообщает ребенку, что не может
обработать исключение, вынуждая ребенка делать это самостоятельно через handler.

То есть если сделать вот так:

scope.launch { 
 
   launch(SupervisorJob() + CoroutineExceptionHandler) {
 
   }
}

то скоуп никогда не узнает о проблемах в дочерней корутине.

Итак: 
------
------
1. Когда мы передаем какой-либо Job в билдер launch, то этот Job будет использован, 
как родитель создаваемой корутины. Т.е. мы подменяем родительский Job в контексте дочерней корутины.

2. SupervisorJob останавливает распространение ошибки ВВЕРХ и горизонтально по своему уровню.

Exception в async-корутинах:
----------------------------

NOTE: async-корутина НЕ УМЕЕТ обрабатывать исключения. Когда в ней возникает исключение,
то она как и положено сообщает родителю, а затем выбрасывает его ПОВТОРНО в методе await(). 

В данном случае получается, что ошибка распространяется двумя путями:
- по иерархии корутин вверх
- и просто внутри кода через exception внутри await().

launch {
 
   val deferred = async {
       // exсeption !!!!
   }
 
   // ...
 
   val result = deferred.await()
 
   // ...
 
}

Если в коде выше не обернуть await() в try/catch, то launch получит два одинаковых
исключения: первое по линии job'ов, второе внутри своего кода.

Второй момент важен: не смотря на то, что получив исключение по лииии job'ов launch
перейдет в завершенное состояние, его код продолжит выполняться. И тут он ловит
исключение второй раз - в await(). При использовании try/catch можно выполнить
код идущий после await. Иначе второе исключение придется снова отправить наверх по
линии job'ов. Подробности в уроке 15.

Исключения в suspend-функции:
-----------------------------

Если suspend-функция сама ловит исключения, обрабатывает или соощает о них через
resumeWithException(), то все норм.

Если suspend-функция не поймала исключение в try/catch, то получим крэш.

****************************************************************************************************
	Урок 16. Отмена корутины.
****************************************************************************************************	

При отмене корутины она извещает об этом своего родителя и своих детей и делает это через
механизм ИСКЛЮЧЕНИЙ генеря CancellationException. Родитель на это никак не реагирует, разве что
отписывается, если ждал завершения этого ребенка. А дети получив CancellationException отменяют себя.

Т.е. при отмене корутина отменяет все свои дочерние и далее вниз. А наверх отмена не идет.

Поведение suspend функции при отмене корутины:
----------------------------------------------

Suspend функции бывают обычные и отменяемые (cancellable). Обычные мы создаем оператором suspendCoroutine, 
а отменяемые - suspendCancellableCoroutine.

Обычные suspend функции не обращают внимания на то, что корутина отменилась. Они работают в обычном 
режиме и возвращают результат.

А отменяемые suspend функции при старте подписываются на отмену корутины. Когда происходит отмена корутины, 
suspend функция получает об этом уведомление с CancellationException и сразу шлет этот Exception в Continuation, 
как результат своей работы. Но при этом не ОСТАНАВЛИВАЕТ своей работы и фигачит до конца ))

Чтобы прервать работу suspend функции в случае отмены вызвавшей ее корутины, нам доступен специальный 
колбэк invokeOnCancellation: 

suspend fun myCancellableSuspendFunction(): String {
   return suspendCancellableCoroutine {continuation ->
 
       continuation.invokeOnCancellation {
           // ...
       }
 
       // ...
 
   }
}

Он будет вызван сразу, как только корутина будет отменена. И в нем мы сможем ПОПЫТАТЬСЯ отменить уже 
запущенную асинхронную работу.

****************************************************************************************************
	Урок 17. coroutineScope, supervisorScope
	
	coroutineScope	-->>	ScopeCoroutine
	withContext		-->>	ScopeCoroutine
	supervisorScope	-->>	SupervisorCoroutine
	runBlocking		-->>	BlockingCoroutine
	
****************************************************************************************************

fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R { 
	. . .
	<some_code> 
	. . . 
	
}

coroutineScope это:
- suspend-функция
- создатель новой корутины ScopeCoroutine для запуска в ней кода <some_code>

Как я понял - это способ выделить отдельные корутины в некий "домен ошибок", то есть 
в этих корутинах могут случаться ошибки, но они не должны влиять на работу других
корутин вне этого домена.

Итак, coroutineScope - это suspend функция, внутри которой запускается специальная корутина ScopeCoroutine.
Код, который мы пишем в блоке coroutineScope, становится кодом этой ScopeCoroutine.

scope.launch(CoroutineName("1")) {
 
   coroutineScope {
 
       launch(CoroutineName("1_2")) {
           // exception
       }
   }
}

При этом выстраивается связь: 'Scope <-- Coroutine_1 <-- ScopeCoroutine <-- Coroutine_1_2'

Основная фишка:
---------------
ScopeCoroutine узнав об ошибке от вложенной корутины говорит ей, что МОЖЕТ ошибку обработать,
но по факту даже не пытается. Вместо этого она:

- отменяет себя и ВСЕ дочерние корутины.
- НЕ передает ошибку родителю, но выстреливает в виде exception в месте вызова функции coroutineScope. 

В нашем случае, если в корутине 1_2 произойдет ошибка, то она пойдет в ScopeCoroutine, которая отменит себя 
и своих детей. И больше никто не узнает об ошибке. Но... Хотя ошибка и не будет передана по цепочке Job'ов, 
она выстрелит в виде exception в месте вызова самой coroutineScope (напомню, что coroutineScope есть suspend-функция). 
А далее как обычно ! Поэтому, чтобы не наипнуть родительий код нужно оборачивать вызов coroutineScope в try/catch:

scope.launch(CoroutineName("1")) {
 
   try {
       coroutineScope {
           launch(CoroutineName("1_1")) {
               // ...
           }
 
           launch(CoroutineName("1_2")) {
               // exception
           }
       }
   } catch (e: Exception) {
       // ...
   }
	. . . .

}

NOTE: Обработчики CoroutineExceptionHandler не работают внутри coroutineScope, потому что ScopeCoroutine принимает ошибку 
от корутины 1_2 и говорит, что МОЖЕТ ее обработать. Поэтому дочерняя корутина на заморачивается с обработчиком.

NOTE: coroutineScope ЖДЕТ завершения всех своих дочерних корутин и после этого завершается. Она может вернуть результат 
и это будет результат работы её кода, а не дочерних корутин.

withContext
-----------------
Suspend-функция, которая позволяет изменить элементы текущего контекста и запустить на модифицированном
контексте ScopeCoroutine. Все остальное как у coroutineScope.

Так как она suspended, то удобно использовать, если требуется результаты асинхронной работы передать в MAIN:

launch {
   // get data from network or database
   // ...
 
   withContext(Dispatchers.Main) {
       // show data on the screen
       // ...
   }
   // ...
}

supervisorScope
---------------
Это тоже suspend-функция и тоже создает "домен ошибок" внутри создаваемой корутины SupervisorCoroutine.
"Домен ошибок" в данном случае более таргетированный. Поясню: при возникновении ошибки в дочерней корутине
SupervisorCoroutine отвечает ей, что НЕ МОЖЕТ обработать исключение и дочерняя корутина вынуждена использовать
CoroutineExceptionHandler (если он у неё есть). Кроме того SupervisorCoroutine НЕ ОТМЕНИТ других своих детей,
ничего не сообщит "наверх" ни по линии Job'ов, ни в виде exception в месте вызова supervisorScope.

runBlocking
--------------
БЛОКИРУЕТ (!!!) поток на котором её запустили пока не завершит свою работу (и пока не дождется завершения дочерних корутин)
Для выполнения кода создает BlockingCoroutine. Если в произойдет ошибка, то все дочерние корутины отменяются и она выбросит
исключение в месте своего вызова. Также он может вернуть результат своей работы.


****************************************************************************************************
	Уроки 18/19. Channels
****************************************************************************************************	

Channels - средство обмена между КОРУТИНАМИ. Механизм напоминает Java BlockingQueue и отчасти паттерн Producer-Consumer.
Channel - потокобезопасен, нам не надо самим возиться с блокировками и синхронностью.

val channel = Channel<Int>()
 
launch {
   // ...
   channel.send(5)
   // ...
}
 
launch {
   // ...
   val i = channel.receive()
   // ...
}


send(..) и receive() - это suspend-функции. Каждая из них "засыпает", если не может сразу выполнить свою работу.

send(data) собирается отправить данные:
---------------------------------------
> проверяет наличие в channel'е инстанса ReceiveElement (то есть ожидающего получателя). Если такой инстанс есть,
  то берет оттуда continuation и вызывает его continuation.resume(data). То есть данные передаются получателю
  через resume.
> если в channel'е нет инстанса ReceiveElement, то создается инстанс SendElement, туда записываются data и
  continuation отправителя. Далее обычный возврат из suspend-функции с кодом COROUTINE_SUSPENDED. Отправитель
  "заснет" пока получатель не получит сообщение и не разбудит отправителя вызовом continuation.resume().
  
receive() собирается получить данные:  
-------------------------------------
> проверяет наличие в channel'е инстанса SendElement (то есть ожидающего отправителя). Если такой инстанс есть,
  то оттуда извлекаются data и continuation. Данные используются в качестве результата вызова метода receive, а
  у continuation вызывается resume, чтобы возобновить выполнение корутины отправителя.
> если в channel'е нет инстанса SendElement, то создается инстанс ReceiveElement. Туда помещается continuation
  корутины получателя и выполняется возврат из receive c кодом COROUTINE_SUSPENDED.

Так по кругу и гоняют сообщения. Особенность в том, что каждый раз корутина ожидающего резюмится в потоке активного !!!
То есть, если "спит" получатель, то его корутина "проснется" когда отправитель в СВОЕМ потоке вызовет resume получателя.
ХЗ что там под капотом, но видимо когда в процессе работы continuation.resume() дело доходит до вызова invokeSuspend,
то вызывается диспетчер связанный с continuation этого resume и он переводит вызов invokeSuspend'а на поток своего
пула. Корутина ведь не может войти в invokeSuspend в потоке чужого диспетчера. Я для теста накидал вот такой код:

fun main() {

    /**
     * Для чистоты эксперимента создаем свой пул
     */
    val pool = Executors.newFixedThreadPool(5).asCoroutineDispatcher()

    val data = 5

    runBlocking {

        val channel = Channel<Int>()

        launch(pool) {
            delay(300)
            println("send $data '${Thread.currentThread().name}'")
            channel.send(data)
            println("send done '${Thread.currentThread().name}'")
        }

        launch(Dispatchers.IO) {
            delay(1000)
            println("receive is starting '${Thread.currentThread().name}'")
            val i = channel.receive()
            println("receive done with $i '${Thread.currentThread().name}'")
        }
    }
}

и получил результат:

	send 5 'pool-1-thread-2'
	receive is starting 'DefaultDispatcher-worker-1'
	receive done with 5 'DefaultDispatcher-worker-1'
	send done 'pool-1-thread-3'

То есть все работают в потоках своих диспетчеров.

Итак, видно что send(..) и receive() фунциклируют по очереди ожидая друг друга. Однако это
можно обойти с помощью channel'а CONFLATED. В этом случае отправитель может накидывать в канал
постоянно не дожидаясь чтения данных получателем. Новые данные затирают предыдущие. receive 
получает значение, которое на момент вызова находится в канале.

Можно организовать канал с буфером и отправитель сможет без остановки запулить в канал столько
элементов сколько свободных мест в буфере (см урок).

Закрытие канала методом close(): 
=================================
1. Закрывает отправитель. 
------------------------
Если получатель попробует получить данные после закрытия (или уже ждет данные в момент закрытия канала 
отправителем), то метод receive получит объект Closed и выбросит исключение ClosedReceiveChannelException.
Тут можно либо заранее проверять закрытость канала через isClosedForReceive, либо, чтобы не возиться 
с отловом и обработкой исключения, получать данные так:

launch {
 
   for (element in channel) {
       // ...
   }
 
}

или так:

launch {
	channel.consumeEach { element ->
		// ...
	}
}	

NOTE: Я сначала подумал, что этот for(...) какой-нибудь особый CoroutineScope.for(...), но оказалось, что обычный.
Просто из channel'а создается iterator класса ChannelIterator позволяющий забирать из канала в обычном 
цикле for. Этот же итератор отвечает за перехват о обработку ClosedReceiveChannelException.

NOTE: Вот так получить итератор 'channel.iterator()'

2. Закрывает получатель. 
------------------------
Если отправитель вызовет send на закрытом канале, то получит исключение ClosedSendChannelException с последующим
крэшем (если не обработает). Отправитель может использовать метод channel.isClosedForSend(), чтобы определить, 
можно ли отправлять данные в канал.

NOTE: Если ОТМЕНИТЬ корутину отправителя/получателя, то другая сторона ничего не узнает и продолжит ждать. Выйти из положения
можно таким поведением в отменяемой корутине - подписаться на свою отмену и закрыть канал явно:

launch {
   coroutineContext[Job]?.invokeOnCompletion {
       channel.close()
   }
   // ...
}

NOTE: Каналы позволяют одновременно использовать несколько отправителей/получателей (см урок). Если получателей несколько, 
то данные будут разделены между ними, и каждый получит только часть от всех отправляемых данных. Чтобы все получатели 
смогли получить все данные, необходимо использовать BroadcastChannel (есть важные особенности, см урок).

Создать:
--------
val broadcastChannel = BroadcastChannel<Int>(buffer_size),   1 <= buffer_size

Отправить:
----------
broadcastChannel.send(5)

Подписаться...
-----------
val channel = broadcastChannel.openSubscription()

...а потом получить данные:
    -----------------------
channel .receive(); for (...); consumeEach {....};

NOTE: 
1. Новый подписчик получает только новые данные из последующих методов send(..). Он не получит текущее содержимое буфера. 
2. Метод send ждет пока все подписанты прочитают очередное сообщение.


****************************************************************************************************
	Урок 20. Flow
****************************************************************************************************	

Существуют 2 интерфейса: Flow и FlowCollector

Flow - генерит данные и отдает коллектору (FlowCollector) в методе Flow::collect
FlowCollector - принимает данные и что-то с ними делает, например работает как map или передает конечному получателю.

public interface Flow<out T> {
     public suspend fun collect(collector: FlowCollector<T>)
}

public interface FlowCollector<in T> {
   public suspend fun emit(value: T)
}

И как-то так должно быть:
------------------------

class Test : Flow<Int> {

	fun collect(collector: FlowCollector<Int>) {
		range(1..10).forEach { i -> collector.emit(i) }
	}
	
}

То есть Flow - это готовый генератор, который НАЧНЁТ генерить при получении коллектора. Будет коллектор - будут данные.
Это аналог Rx Observable: есть подписка есть и данные.

Однако ещё существует отдельная extension-функция Flow.collect { пользов_лямда }. Вот такая:

suspend inline fun <T> Flow<T>.collect(crossinline action: suspend (value: T) -> Unit): Unit =

    this.collect(object : FlowCollector<T> {
        override suspend fun emit(value: T) = action(value)
    })

Обрати внимание, что она САМОСТОЯТЕЛЬНО создает коллектор и его метод emit просто ретранслирует данные сгенеренные
коллектором в пользовательскую лямду. То есть Flow - это некий черный ящик, генерящий данные и спускающий их в коллектор,
а наша пользовательская лямда их принимает из коллектора.

Под капотом билдера flow :
----------------------------

Это аналог хорошо знакомого

    Observable.create<Int> {emitter ->
        emitter.onNext(1)
        emitter.onNext(2)
        emitter.onComplete()
    }

Прототип оператора:

fun <T> flow( block: suspend FlowCollector<T>.() -> Unit ): Flow<T> = SafeFlow(block)

Последовательность вызовов:

1. val safeFlow = flow<Int> { // this: FlowCollector<Int>

  // this ==> collector

  val data1 = 1
  val data2 = 2
  this.emit(data1)
  this.emit(data2)
}

2. safeFlow.collect { data -> println(data) } // Это вызов extension-функции, рассмотренной выше !!! А не метода Flow::collect.

То есть это способ создать свой Flow. Оператор flow {...} сначала создает SafeFlow, передавая ему лямду в конструктор. 
А потом вызов extension-функции safeFlow.collect {...} запускает генератор в действие: создаётся новый FlowCollector и 
на нем выполняется код генератора из конструктора SafeFlow. А этот генератор отправляет свои данные через emit в другую
лямду { data -> println(data) }

Вообще получается что функция collect у интерфейса Flow нужна для того, чтобы "направить" генерируемые данные через
коллектор куда-то дальше. Это дальше зависит от того как фактически реализована emit у коллектора. Flow может и не
генерить данные сам (как показано выше). Главное чтобы они откуда-то брались.

NOTE: вызов emit является suspend, safeFlow.collect тоже suspend

Ещё пара билдеров для кастомных Flow:

asFlow()
---------

val flow = listOf("a","b","c").asFlow()


flowOf(vararg ...)
-----------------

val flow = flowOf("a","b","c")

Можно сделать Flow из SUSPEND-функции:
--------------------------------------

suspend fun getData(): Data
val flow = ::getData.asFlow()

Все эти фичи на базе flow {...}

Операторы бывают двух типов: Intermediate и Terminal
----------------------------------------------------

Intermediate - это map, filter и пр. Они выполняются действия с контентом, но эмиссию не запускают.
Terminal - запускают генератор и работают с результатом.

Пример Intermediate:
--------------------

val flow = flowOf(1,2,3).map { it * 10 }

NOTE: Каждый последующий оператор создает ОБЕРТКУ над предыдущим и работает это вот так:
допустим у нас один Flow генерит строки, а второй переводит их в верхний регистр. Итоговая матрешка будет следующей:

val flowStrings = flow {
   emit("abc")
   emit("def")
   emit("ghi")
}

val flowUpperCase = flow { // this: collector
 
   flowStrings.collect {
       emit(it.toUpperCase())	// это emit на коллекторе this
   }
 
}

NOTE: flowStrings.collect{...} можно заменить на 'emitAll(flowStrings)'

Получается интересно: мы в принимающую лямду внутреннего Flow помещаем вызов emit коллектора внешнего Flow !!!
NOTE: Цепочка стартанет только после вызова flowUppderCase.collect {...}

Чтобы получить именно оператор нужно реализовать тоже самое через extension-функцию

fun Flow<String>.toUpperCase(): Flow<String> = flow { // this: collector

   collect {					// вызов на ресивере оператора (или на внутреннем Flow. см. предыдущий пример)
       emit(it.toUpperCase())	// это emit на коллекторе this
   }
   
}

Вообще для создания своих операторов рекомендуется метод 'transform':

flowStrings.transform { value ->
   emit(value.toUpperCase())
   emit(value)
}

Каждую строку превращаем в две: одна большими буквами, вторая оригинальными. 


Пример Terminal:
----------------

collect, single, reduce, count, first, toList, toSet, fold

NOTE: Terminal операторы запускают Flow так же, как это делает collect. Результатом их работы является не Flow,
а данные, полученные из Flow.







