****************************************************************************************************
	Урок 1
****************************************************************************************************

Job
=====
Mожно запускать корутину внутри корутины. Их ДЖОБЫ будут СВЯЗАНЫ между собой отношениями PARENT-CHILD,
что является отдельным механизмом, который влияет на ОБРАБОТКУ ОШИБОК И ОТМЕНУ КОРУТИН.


КСТАТИ: SuspendLambda живет в пакете kotlin.coroutines.jvm.internal в файле ContinuationImpl.kt

****************************************************************************************************
	Урок 2 (https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-builders)
****************************************************************************************************


ПИПЕЦ !!!! (kotlin.coroutines.jvm.internal.ContinuationImpl.kt)

class SuspendLambda : ContinuationImpl {...}

	class ContinuationImpl : BaseContinuationImpl {...}
	
		class BaseContinuationImpl (completion : Continuation) : Continuation<Any?> {
		
			override fun resumeWith(result: Result<Any?>) {...}
			abstract fun invokeSuspend(result: Result<Any?>): Any?
			open fun create(value: Any?, completion: Continuation<*>): Continuation<Unit>
		}

Две последние функции вставляются компилятором в тот блок кода, который мы передаем в launch.
Получается, что этот блок кода становится инстансом BaseContinuationImpl ну и соответственно Continuation.

 =========================================================================================================

Далее подробности.


interface Job : CoroutineContext.Element {
	. . . .
}

interface CoroutineScope {
    val coroutineContext: CoroutineContext
}

interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}


NOTE: !!!!! Корутина реализует все эти три интерфейса ! То есть resumeWith(...) содержится в НЕЙ !


Рассмотрим работу билдера launch
--------------------------------

Существует такой класс как AbstractCoroutine, который является базовым для корутин, создаваемых билдерами,
и он имплементит три основных интерфейса. А именно:

 - Continuation
 - CoroutineScope
 - Job

То есть каждая созданная корутина является Job'ом, содержит context и имеет метод resumeWith(...)

NOTE: Из AbstractCoroutine создаются LazyStandaloneCoroutine, StandaloneCoroutine и пр.

Билдер:
-------

fun CoroutineScope.launch(
	context: CoroutineContext, 
	start: CoroutineStart, 
	block: suspend CoroutineScope.() -> Unit): Job
	
Особый интерес здесь представляет третий аргумент 'suspend CoroutineScope.() -> Unit'. При компиляции это превращается в инстанс,
наследующий от SuspendLambda и от котлиновской версии Function2 (котлиновская Function2 вызывается через invoke).
В качестве this туда передается CoroutineScope. 

Итак, в общих чертах алгоритм такой: билдер, имея скоуп, context и start, создает инстанс корутины. Далее он инстанциирует 
лямду (она же Function2) и вызывает её Function2.invoke передавая аргументом корутину, которая является Continuation.
Внутри лямды происходит цепочка вызовов: invoke -> create -> invokeSuspend и работа пошла.

Теперь подробнее рассмотрим как это выглядит в байт коде:
---------------------------------------------------------

Это оболочка вокруг invokeSuspend внутри ревертированного Java-кода. Она не очень информативна:

Function2< CoroutineScope; Continuation; Object; > {

	public final invoke(Object; Object;) Object;	

	public final create(Object; Continuation;) Continuation;
	
	public final invokeSuspend(Object;) Object;
	
};

// Вот описание класса, который создается на базе лямды:
--------------------------------------------------------

// class signature 
	SuspendLambda; Function2<CoroutineScope; Continuation<Unit>; Object;>;

// class declaration
	CoCoKt$main$1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object>

// Попробуем восстановить:

class CoCoKt$main$1 : SuspendLambda, Function2 {

	// Конструктор, вызывающий конструктор SuspendLambd'ы
	<init>(Continuation;) V
		call SuspendLambda.<init> (Continuation;) V

	public final invoke(var1 CoroutineScope; var2 Continuation;) Object;  ==>> Это Function2::invoke
		create(var1, var2).invokeSuspend

	public final create(var1 CoroutineScope; var2 Continuation;) Continuation;
		return var2
	
	public final invokeSuspend(Object;) Object;

}

Видно, что в конструкторе передается Continuation (он же корутина). Теперь этот Continuation можно будет отдавать
во внутренние вызовы suspend-функций.

NOTE: Остается неясным как resumeWith узнает адрес invokeSuspend'а, чтобы её вызывать.

// Далее пошаговый код её создания:
------------------------------------	
	
// Создаем Job скоупа и скоуп	
val job1 = INVOKESTATIC JobKt.Job$default (Job; Object;) CompletableJob;	
	checkcast (job == context) ??? хз, наверное должно каститься
val scope = INVOKESTATIC CoroutineScope (CoroutineContext;) CoroutineScope;

// Это создается инстанс из блока кода для корутины (см класс выше)
val coroutine = NEW CoCoKt$main$1

call coroutine.constructor => INVOKESPECIAL CoCoKt$main$1.<init> (Continuation;)V
	checkcast (suspendLamda == Function2) ==>> Вот, лямда оборачивается в (SuspendLambda + Function2)

// И вот job самой корутины и её старт. Обрати внимание, что билдеру передается 
val job2 INVOKESTATIC BuildersKt.launch$default (CoroutineScope; CoroutineContext; CoroutineStart; Function2; Object;) Job;  	
		

++++++++++++++++++++++++++++++++

Вот цепочка вызовов. 

 
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    startOptions: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    val coroutine = StandaloneCoroutine(context, active = true)
    coroutine.start(startOptions, coroutine, block)
    return coroutine
}

 -->> launch создает корутину и стартует её, передавая наш block (который SuspendLambda + Function2) 

public fun <R> Coroutine::start(startOptions: CoroutineStart, receiver: R, block: suspend R.() -> T) {
    startOptions(block, receiver, this)
}

class CoroutineStart {

	operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
		block.startCoroutineCancellable(completion)
		
	fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
		createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
	}
}

public fun <T> (suspend () -> T).createCoroutineUnintercepted(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<kotlin.Unit> { /* compiled code */ }

****************************************************************************************************
	Урок 3 Suspend Functions
****************************************************************************************************

Каждая suspend функция получает первым, неявным, аргументом ссылку на enclosed Continuation. 
Через его resumeWith будет выполнен возврат результата.

suspend fun someProc(<implicit continuation: Continuation>, url: String): File { 
	return suspendCoroutine { continuation -> 
		. . . 
		continuation.resume(result)
		
		... или в случае ошибки ...
		
		continuation.resumeWithException(error)
	
	}
}

suspendCoroutine служит промежуточным звеном, поставляющим continuation внутрь кода нашей функции.

Создавая suspend функцию, мы должны позаботиться о том, чтобы она выполнялась асинхронно в другом потоке 
или вернула результат сразу. Если же мы напишем в suspend функции код, блокирующий поток, то слово suspend
нам никак не поможет. 

Если не вызвать никакой continuation.resume..., то корутина никогда не продолжится.

****************************************************************************************************
	Урок 4 Возврат значения из Suspend-функции и в целом из корутины.
****************************************************************************************************
Итак, resume вызываетcя в двух случаях: 
	- для первого запуска корутины. 
	- из колбэков suspend-функций, когда они отработали.

Если resume вызвала функцию	invokeSuspend, то она ждет в ответ либо 'COROUTINE_SUSPENDED',
либо иное значение, которое будет означать завершение всей корутины и возврат результата.
Это то что касается вызовов ИЗ resume.

Когда вызывается сама resume, то свой аргумент она сразу передает далее в invokeSuspend
и ожидает два варианта результата (см выше).

class ContinuationImpl {

	void resume(Object result) {
		val result = invokeSuspend(result)
		
		// result: ЛИБО 'COROUTINE_SUSPENDED' ЛИБО конечный результат ВСЕЙ корутины
		
	}

	// В операторах 'case' нет ни break ни return. Значит если у suspend-функции результат готов сразу,
	// то просто переходим на следующий 'case' без возврата в resume.

                                                                                                                            -
	Object invokeSuspend(Object result) {
		switch (label) {
			case 0: {
				url = buildUrl();
				label = 1;
	 
				// Если функция download может сразу достать файл из кэша, то она не вызывает resume(file),
				// а просто возвращает это значение и код внутри invokeSuspend переходит на следующий case.
				result = download(url, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 1: {
				file = (File) result;
				toast("Url is downloaded: " + url);
				label = 2;
	 
				result = unzip(file, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 2: {
				size = (Long) result;
				toast("File is unzipped, size: " + size);
				return size;
			}
		}
	 
		throw new IllegalStateException("...");
	}
}

----------------------------------------
Вот примерный код suspend-функции, которая может вернуть результат из кэша.

Object download(String url, Continuation continuation) {
 
    File file = getFileFromCache(url);
	
	if(file == null) {
        networkService.download(url, new NetworkService.Callback() {
            @Override
            public void onSuccess(File result) {
                continuation.resume(result);
            }
 
            @Override
            public void onFailure(Exception error) {
                continuation.resumeWithException(error);
            }
        });	
		
		return COROUTINE_SUSPENDED;
	}
	
	return file
}
	

		