0****************************************************************************************************
	Урок 1
****************************************************************************************************

Job
=====
Mожно запускать корутину внутри корутины. Их ДЖОБЫ будут СВЯЗАНЫ между собой отношениями PARENT-CHILD,
что является отдельным механизмом, который влияет на ОБРАБОТКУ ОШИБОК И ОТМЕНУ КОРУТИН.


КСТАТИ: SuspendLambda живет в пакете kotlin.coroutines.jvm.internal в файле ContinuationImpl.kt

****************************************************************************************************
	Урок 2 (https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-builders)
****************************************************************************************************


ПИПЕЦ !!!! (kotlin.coroutines.jvm.internal.ContinuationImpl.kt)

class SuspendLambda : ContinuationImpl {...}

	class ContinuationImpl : BaseContinuationImpl {...}
	
		class BaseContinuationImpl (completion : Continuation) : Continuation<Any?> {
		
			override fun resumeWith(result: Result<Any?>) {...}
			abstract fun invokeSuspend(result: Result<Any?>): Any?
			open fun create(value: Any?, completion: Continuation<*>): Continuation<Unit>
		}

Две последние функции вставляются компилятором в тот блок кода, который мы передаем в launch.
Получается, что этот блок кода становится инстансом BaseContinuationImpl ну и соответственно Continuation.

 =========================================================================================================

Далее подробности.


interface Job : CoroutineContext.Element {
	. . . .
}

interface CoroutineScope {
    val coroutineContext: CoroutineContext
}

interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}


NOTE: !!!!! Корутина реализует все эти три интерфейса ! То есть resumeWith(...) содержится в НЕЙ !


Рассмотрим работу билдера launch
--------------------------------

Существует такой класс как AbstractCoroutine, который является базовым для корутин, создаваемых билдерами,
и он имплементит три основных интерфейса. А именно:

 - Continuation
 - CoroutineScope
 - Job

То есть каждая созданная корутина является Job'ом, содержит context и имеет метод resumeWith(...)

NOTE: Из AbstractCoroutine создаются LazyStandaloneCoroutine, StandaloneCoroutine и пр.

Билдер:
-------

fun CoroutineScope.launch(
	context: CoroutineContext, 
	start: CoroutineStart, 
	block: suspend CoroutineScope.() -> Unit): Job
	
Особый интерес здесь представляет третий аргумент 'suspend CoroutineScope.() -> Unit'. При компиляции это превращается в инстанс,
наследующий от SuspendLambda и от котлиновской версии Function2 (котлиновская Function2 вызывается через invoke).
В качестве this туда передается CoroutineScope. 

Итак, в общих чертах алгоритм такой: билдер, имея скоуп, context и start, создает инстанс корутины. Далее он инстанциирует 
лямду (она же Function2) и вызывает её Function2.invoke передавая аргументом корутину, которая является Continuation.
Внутри лямды происходит цепочка вызовов: invoke -> create -> invokeSuspend и работа пошла.

Теперь подробнее рассмотрим как это выглядит в байт коде:
---------------------------------------------------------

Это оболочка вокруг invokeSuspend внутри ревертированного Java-кода. Она не очень информативна:

Function2< CoroutineScope; Continuation; Object; > {

	public final invoke(Object; Object;) Object;	

	public final create(Object; Continuation;) Continuation;
	
	public final invokeSuspend(Object;) Object;
	
};

// Вот описание класса, который создается на базе лямды:
--------------------------------------------------------

// class signature 
	SuspendLambda; Function2<CoroutineScope; Continuation<Unit>; Object;>;

// class declaration
	CoCoKt$main$1 extends SuspendLambda implements Function2<CoroutineScope, Continuation<? super Unit>, Object>

// Попробуем восстановить:

class CoCoKt$main$1 : SuspendLambda, Function2 {

	// Конструктор, вызывающий конструктор SuspendLambd'ы
	<init>(Continuation;) V
		call SuspendLambda.<init> (Continuation;) V

	public final invoke(var1 CoroutineScope; var2 Continuation;) Object;  ==>> Это Function2::invoke
		create(var1, var2).invokeSuspend

	public final create(var1 CoroutineScope; var2 Continuation;) Continuation;
		return var2
	
	public final invokeSuspend(Object;) Object;

}

Видно, что в конструкторе передается Continuation (он же корутина). Теперь этот Continuation можно будет отдавать
во внутренние вызовы suspend-функций.

NOTE: Остается неясным как resumeWith узнает адрес invokeSuspend'а, чтобы её вызывать.

// Далее пошаговый код её создания:
------------------------------------	
	
// Создаем Job скоупа и скоуп	
val job1 = INVOKESTATIC JobKt.Job$default (Job; Object;) CompletableJob;	
	checkcast (job == context) ??? хз, наверное должно каститься
val scope = INVOKESTATIC CoroutineScope (CoroutineContext;) CoroutineScope;

// Это создается инстанс из блока кода для корутины (см класс выше)
val coroutine = NEW CoCoKt$main$1

call coroutine.constructor => INVOKESPECIAL CoCoKt$main$1.<init> (Continuation;)V
	checkcast (suspendLamda == Function2) ==>> Вот, лямда оборачивается в (SuspendLambda + Function2)

// И вот job самой корутины и её старт. Обрати внимание, что билдеру передается 
val job2 INVOKESTATIC BuildersKt.launch$default (CoroutineScope; CoroutineContext; CoroutineStart; Function2; Object;) Job;  	
		

++++++++++++++++++++++++++++++++

Вот цепочка вызовов. 

 
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    startOptions: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    val coroutine = StandaloneCoroutine(context, active = true)
    coroutine.start(startOptions, coroutine, block)
    return coroutine
}

 -->> launch создает корутину и стартует её, передавая наш block (который SuspendLambda + Function2) 

public fun <R> Coroutine::start(startOptions: CoroutineStart, receiver: R, block: suspend R.() -> T) {
    startOptions(block, receiver, this)
}

class CoroutineStart {

	operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
		block.startCoroutineCancellable(completion)
		
	fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {
		createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))
	}
}

public fun <T> (suspend () -> T).createCoroutineUnintercepted(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<kotlin.Unit> { /* compiled code */ }

****************************************************************************************************
	Урок 3 Suspend Functions
****************************************************************************************************

Каждая suspend функция получает первым, неявным, аргументом ссылку на enclosed Continuation. 
Через его resumeWith будет выполнен возврат результата.

suspend fun someProc(<implicit continuation: Continuation>, url: String): File { 
	return suspendCoroutine { continuation -> 
		. . . 
		continuation.resume(result)
		
		... или в случае ошибки ...
		
		continuation.resumeWithException(error)
	
	}
}

suspendCoroutine служит промежуточным звеном, поставляющим continuation внутрь кода нашей функции.

Создавая suspend функцию, мы должны позаботиться о том, чтобы она выполнялась асинхронно в другом потоке 
или вернула результат сразу. Если же мы напишем в suspend функции код, блокирующий поток, то слово suspend
нам никак не поможет. 

Если не вызвать никакой continuation.resume..., то корутина никогда не продолжится.

****************************************************************************************************
	Уроки 4 и 5. Возврат значения из Suspend-функции и в целом из корутины.
****************************************************************************************************

Итак, resume вызываетcя в двух случаях: 
	- для первого запуска корутины. 
	- из колбэков suspend-функций, когда они отработали.

Если resume вызвала функцию	invokeSuspend, то она ждет в ответ либо 'COROUTINE_SUSPENDED',
либо иное значение, которое будет означать завершение всей корутины и возврат результата.
Это то что касается вызовов ИЗ resume.

Когда вызывается сама resume, то свой аргумент она сразу передает далее в invokeSuspend
и ожидает два варианта результата (см выше).

class ContinuationImpl {

	void resume(Object result) {
		val result = invokeSuspend(result)
		
		// result: ЛИБО 'COROUTINE_SUSPENDED' ЛИБО конечный результат ВСЕЙ корутины
		
	}

	// В операторах 'case' нет ни break ни return. Значит если у suspend-функции результат готов сразу,
	// то просто переходим на следующий 'case' без возврата в resume.

                                                                                                                            -
	Object invokeSuspend(Object result) {
		switch (label) {
			case 0: {
				url = buildUrl();
				label = 1;
	 
				// Если функция download может сразу достать файл из кэша, то она не вызывает resume(file),
				// а просто возвращает это значение и код внутри invokeSuspend переходит на следующий case.
				result = download(url, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 1: {
				file = (File) result;
				toast("Url is downloaded: " + url);
				label = 2;
	 
				result = unzip(file, this);
				if (result == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED;
			}
			case 2: {
				size = (Long) result;
				toast("File is unzipped, size: " + size);
				return size;
			}
		}
	 
		throw new IllegalStateException("...");
	}
}

----------------------------------------
Вот примерный код suspend-функции, которая может вернуть результат из кэша.

Object download(String url, Continuation continuation) {
 
    File file = getFileFromCache(url);
	
	if(file == null) {
        networkService.download(url, new NetworkService.Callback() {
            @Override
            public void onSuccess(File result) {
                continuation.resume(result);
            }
 
            @Override
            public void onFailure(Exception error) {
                continuation.resumeWithException(error);
            }
        });	
		
		return COROUTINE_SUSPENDED;
	}
	
	return file
}
	
****************************************************************************************************
	Уроки 6
****************************************************************************************************	

Перед тем как полностью завершиться метод invokeSuspend меняет состояние корутины (внутри Job) на completed.


****************************************************************************************************
	Урок 7. Scope
****************************************************************************************************	

Scope - это корень иерархии корутин. Точнее его Job - корень иерархии Job'ов все корутин скоупа.

public interface CoroutineScope {    
    // By convention, should contain an instance of a [job][Job] to enforce structured concurrency.
    public val coroutineContext: CoroutineContext
}

NOTE: смысл конструкции [job][Job]. Дело в том, что интерфейсы Job и CoroutineScope наследуются корутинами
через базовый класс AbstractCoroutine. И благодаря полиморфизму корутину можно представить как Job и как
CoroutineContext (подробнее в 03_1_Coroutines_Context_Job.txt)

Продолжим. В coroutineContext[Job] живет Job скоупа. У Scope свой собственный Job, который является корнем 
иерархии Job'ов всех корутин скоупа. Вообще иерархия Job'ов - это и есть реализация structured concurrency:
отменяем родительский Job и дочерние тоже отменятся.

Запуск дочерних корутин:

public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
)

Или как мы это делаем к коде программы:

scope.launch {
    // coroutine code block
}

Важный момент: между 'launch' и '{' из аргументов метода launch создается НОВЫЙ Scope со своим Job и на 
этом скоупе стартанет блок лямды. То есть внутри лямды будет свой скоуп в качестве this. И так происходит
во всех операторах launch. Везде 'между 'launch' и '{' создается новый скоуп с новым Job.

Очень хорошо про связи между скоупами контекстами и джобами рассказано здесь:
https://elizarov.medium.com/coroutine-context-and-scope-c8b255d59055

****************************************************************************************************
	Урок 8. Отмена корутины
****************************************************************************************************	

Выполняется через scope.cancel() или job.cancel(). В любом случае это просто меняет
статус Job'а на isActive == false. Код корутины продолжает делать свою работу. Поэтому
для остановки кода нужно в нем ЯВНО проверять статус isActive !!!

Однако, можно подписаться на событие отмены корутины и ориентироваться на него, а не на
проверку isActive. Так делают системные suspend функции (например delay). Свою suspend
функцию с подпиской нужно запускать не через suspendCoroutine, а через suspendCancellableCoroutine.

****************************************************************************************************
	Урок 9. Ожидание завершения корутины
****************************************************************************************************	

scope.launch {
 
   job = launch {
       // ...
   }
 
   // ...
   
   job.join()
}


join() - это suspend функция !!!


Когда создаются вложенные корутины, то родительская перейдет в статус Завершена ТОЛЬКО после того
как ВСЕ дочерние корутины будут завершены. Родительская корутина подписывается на дочерние и ждет
их завершения. Выполнение всего кода корутиной не означает что она завершена !!!


Результат из корутины:
----------------------

scope.launch {
 
   val deferred  = async {
       // ...
   }
 
   // ...
   
   val result = deferred.await()
}


await() - это suspend функция, deferred - наследник job.


Lazy
=====
Удобный механизм создать корутину и передать её job куда-то где она позже будет запущена 
на выполнение через job.start() !!!

NOTE: async-корутину также можно запускать в режиме Lazy. Метод await() стартует ее выполнение !!!







		