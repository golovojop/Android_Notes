Список основных фич, которые применяются в DSL:

1. Operator Overloading (Conventions)
--------------------------------------

	data class Point(val x: Int, val y: Int) { 
		operator fun plus(other: Point): Point { 
			return Point(x + other.x, y + other.y) 
		} 
	} 
	
	p1 + p2, вместо p1.plus(p2)
	
	Тут целая серия перегруженных операторов, включая бинарные и унарные арифметические, сравнение.


2. Operator Overloading (Conventions) get/set для доступа к свойствам по индексу
---------------------------------------------------------------------------------

	operator fun Point.get(index: Int): Int { 
		return when(index) { 
				0 -> x 
				1 -> y 
				else -> throw IndexOutOfBoundsException("Invalid coordinate $index") 
		} 
	} 
	
	val p = Point(10, 20) 
	println(p[1])
	
	В принципе любой класс можно проиндексировать подобным образом и получим доступ к его
	элементам как к колекции.
	
	
3. Infix Functions

	Позволяют структурировать код через chain'изацию вызовов
	
4. Лямда за скобками
=======================

	Если лямда является последним аргументом какой-то функции, то выносим лямду за фигурные скобки
	
	file.use { it.resd() }
	


5. Extension Functions

	Такая функция имеет доступ только к public элементам своего ресивера.




	
	
6. Lambda With Receiver	

	Такая функция тоже имеет доступ только к public элементам своего ресивера.
	
	ВАЖНО: Такие лямды изменяют name resolution context. То есть внутри тела лямды (внутри скобок)
	поиск имен идет по именам элементов ресивера !!! В основном об этом нужно помнить, если такая
	лямда является членом класса !!!
	
	NOTE: Чтобы узнать имеет ли лямда ресивер (и какого типа) нужно посмотреть на сигнатуру
	обычной функции, в которой лямда является аргументом.



Матчасть:
-------------------------

В DSL два вида структурирования
 - вложенные лямды
 - chain'инг вызовов